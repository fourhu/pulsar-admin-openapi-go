/*
Pulsar Admin REST API

This provides the REST API for admin operations

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// NonPersistentTopicApiService NonPersistentTopicApi service
type NonPersistentTopicApiService service

type ApiCompactNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiCompactNPRequest) Authoritative(authoritative bool) ApiCompactNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiCompactNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CompactNPExecute(r)
}

/*
CompactNP Trigger a compaction operation on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiCompactNPRequest
*/
func (a *NonPersistentTopicApiService) CompactNP(ctx _context.Context, tenant string, namespace string, topic string) ApiCompactNPRequest {
	return ApiCompactNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) CompactNPExecute(r ApiCompactNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.CompactNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/compaction"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompactionStatusNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiCompactionStatusNPRequest) Authoritative(authoritative bool) ApiCompactionStatusNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiCompactionStatusNPRequest) Execute() (LongRunningProcessStatus, *_nethttp.Response, error) {
	return r.ApiService.CompactionStatusNPExecute(r)
}

/*
CompactionStatusNP Get the status of a compaction operation for a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiCompactionStatusNPRequest
*/
func (a *NonPersistentTopicApiService) CompactionStatusNP(ctx _context.Context, tenant string, namespace string, topic string) ApiCompactionStatusNPRequest {
	return ApiCompactionStatusNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return LongRunningProcessStatus
func (a *NonPersistentTopicApiService) CompactionStatusNPExecute(r ApiCompactionStatusNPRequest) (LongRunningProcessStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LongRunningProcessStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.CompactionStatusNP")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/compaction"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateMissedPartitionsNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiCreateMissedPartitionsNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateMissedPartitionsNPExecute(r)
}

/*
CreateMissedPartitionsNP Create missed partitions of an existing partitioned topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiCreateMissedPartitionsNPRequest
*/
func (a *NonPersistentTopicApiService) CreateMissedPartitionsNP(ctx _context.Context, tenant string, namespace string, topic string) ApiCreateMissedPartitionsNPRequest {
	return ApiCreateMissedPartitionsNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) CreateMissedPartitionsNPExecute(r ApiCreateMissedPartitionsNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.CreateMissedPartitionsNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/createMissedPartitions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateNonPartitionedTopicNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiCreateNonPartitionedTopicNPRequest) Authoritative(authoritative bool) ApiCreateNonPartitionedTopicNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiCreateNonPartitionedTopicNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateNonPartitionedTopicNPExecute(r)
}

/*
CreateNonPartitionedTopicNP Create a non-partitioned topic.

This is the only REST endpoint from which non-partitioned topics could be created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiCreateNonPartitionedTopicNPRequest
*/
func (a *NonPersistentTopicApiService) CreateNonPartitionedTopicNP(ctx _context.Context, tenant string, namespace string, topic string) ApiCreateNonPartitionedTopicNPRequest {
	return ApiCreateNonPartitionedTopicNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) CreateNonPartitionedTopicNPExecute(r ApiCreateNonPartitionedTopicNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.CreateNonPartitionedTopicNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreatePartitionedTopicNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *int32
}

// The number of partitions for the topic
func (r ApiCreatePartitionedTopicNPRequest) Body(body int32) ApiCreatePartitionedTopicNPRequest {
	r.body = &body
	return r
}

func (r ApiCreatePartitionedTopicNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreatePartitionedTopicNPExecute(r)
}

/*
CreatePartitionedTopicNP Create a partitioned topic.

It needs to be called before creating a producer on a partitioned topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiCreatePartitionedTopicNPRequest
*/
func (a *NonPersistentTopicApiService) CreatePartitionedTopicNP(ctx _context.Context, tenant string, namespace string, topic string) ApiCreatePartitionedTopicNPRequest {
	return ApiCreatePartitionedTopicNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) CreatePartitionedTopicNPExecute(r ApiCreatePartitionedTopicNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.CreatePartitionedTopicNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/partitions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateSubscriptionNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	subscriptionName string
	authoritative *bool
	replicated *bool
	messageId *MessageIdImpl
}

// Is authentication required to perform this operation
func (r ApiCreateSubscriptionNPRequest) Authoritative(authoritative bool) ApiCreateSubscriptionNPRequest {
	r.authoritative = &authoritative
	return r
}
// Is replicated required to perform this operation
func (r ApiCreateSubscriptionNPRequest) Replicated(replicated bool) ApiCreateSubscriptionNPRequest {
	r.replicated = &replicated
	return r
}
// messageId where to create the subscription. It can be &#39;latest&#39;, &#39;earliest&#39; or (ledgerId:entryId)
func (r ApiCreateSubscriptionNPRequest) MessageId(messageId MessageIdImpl) ApiCreateSubscriptionNPRequest {
	r.messageId = &messageId
	return r
}

func (r ApiCreateSubscriptionNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateSubscriptionNPExecute(r)
}

/*
CreateSubscriptionNP Create a subscription on the topic.

Creates a subscription on the topic at the specified message id

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param subscriptionName Subscription to create position on
 @return ApiCreateSubscriptionNPRequest
*/
func (a *NonPersistentTopicApiService) CreateSubscriptionNP(ctx _context.Context, tenant string, namespace string, topic string, subscriptionName string) ApiCreateSubscriptionNPRequest {
	return ApiCreateSubscriptionNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		subscriptionName: subscriptionName,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) CreateSubscriptionNPExecute(r ApiCreateSubscriptionNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.CreateSubscriptionNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subscriptionName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriptionName"+"}", _neturl.PathEscape(parameterToString(r.subscriptionName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	if r.replicated != nil {
		localVarQueryParams.Add("replicated", parameterToString(*r.replicated, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.messageId
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDeduplicationSnapshotIntervalNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiDeleteDeduplicationSnapshotIntervalNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteDeduplicationSnapshotIntervalNPExecute(r)
}

/*
DeleteDeduplicationSnapshotIntervalNP Delete deduplicationSnapshotInterval config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiDeleteDeduplicationSnapshotIntervalNPRequest
*/
func (a *NonPersistentTopicApiService) DeleteDeduplicationSnapshotIntervalNP(ctx _context.Context, tenant string, namespace string, topic string) ApiDeleteDeduplicationSnapshotIntervalNPRequest {
	return ApiDeleteDeduplicationSnapshotIntervalNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) DeleteDeduplicationSnapshotIntervalNPExecute(r ApiDeleteDeduplicationSnapshotIntervalNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.DeleteDeduplicationSnapshotIntervalNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDelayedDeliveryPoliciesNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiDeleteDelayedDeliveryPoliciesNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteDelayedDeliveryPoliciesNPExecute(r)
}

/*
DeleteDelayedDeliveryPoliciesNP Set delayed delivery messages config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiDeleteDelayedDeliveryPoliciesNPRequest
*/
func (a *NonPersistentTopicApiService) DeleteDelayedDeliveryPoliciesNP(ctx _context.Context, tenant string, namespace string, topic string) ApiDeleteDelayedDeliveryPoliciesNPRequest {
	return ApiDeleteDelayedDeliveryPoliciesNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) DeleteDelayedDeliveryPoliciesNPExecute(r ApiDeleteDelayedDeliveryPoliciesNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.DeleteDelayedDeliveryPoliciesNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/delayedDelivery"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteInactiveTopicPoliciesNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiDeleteInactiveTopicPoliciesNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteInactiveTopicPoliciesNPExecute(r)
}

/*
DeleteInactiveTopicPoliciesNP Delete inactive topic policies on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiDeleteInactiveTopicPoliciesNPRequest
*/
func (a *NonPersistentTopicApiService) DeleteInactiveTopicPoliciesNP(ctx _context.Context, tenant string, namespace string, topic string) ApiDeleteInactiveTopicPoliciesNPRequest {
	return ApiDeleteInactiveTopicPoliciesNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) DeleteInactiveTopicPoliciesNPExecute(r ApiDeleteInactiveTopicPoliciesNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.DeleteInactiveTopicPoliciesNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteMaxUnackedMessagesOnConsumerNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiDeleteMaxUnackedMessagesOnConsumerNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteMaxUnackedMessagesOnConsumerNPExecute(r)
}

/*
DeleteMaxUnackedMessagesOnConsumerNP Delete max unacked messages per consumer config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiDeleteMaxUnackedMessagesOnConsumerNPRequest
*/
func (a *NonPersistentTopicApiService) DeleteMaxUnackedMessagesOnConsumerNP(ctx _context.Context, tenant string, namespace string, topic string) ApiDeleteMaxUnackedMessagesOnConsumerNPRequest {
	return ApiDeleteMaxUnackedMessagesOnConsumerNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) DeleteMaxUnackedMessagesOnConsumerNPExecute(r ApiDeleteMaxUnackedMessagesOnConsumerNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.DeleteMaxUnackedMessagesOnConsumerNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteMaxUnackedMessagesOnSubscriptionNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiDeleteMaxUnackedMessagesOnSubscriptionNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteMaxUnackedMessagesOnSubscriptionNPExecute(r)
}

/*
DeleteMaxUnackedMessagesOnSubscriptionNP Delete max unacked messages per subscription config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiDeleteMaxUnackedMessagesOnSubscriptionNPRequest
*/
func (a *NonPersistentTopicApiService) DeleteMaxUnackedMessagesOnSubscriptionNP(ctx _context.Context, tenant string, namespace string, topic string) ApiDeleteMaxUnackedMessagesOnSubscriptionNPRequest {
	return ApiDeleteMaxUnackedMessagesOnSubscriptionNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) DeleteMaxUnackedMessagesOnSubscriptionNPExecute(r ApiDeleteMaxUnackedMessagesOnSubscriptionNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.DeleteMaxUnackedMessagesOnSubscriptionNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePartitionedTopicNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	force *bool
	authoritative *bool
	deleteSchema *bool
}

// Stop all producer/consumer/replicator and delete topic forcefully
func (r ApiDeletePartitionedTopicNPRequest) Force(force bool) ApiDeletePartitionedTopicNPRequest {
	r.force = &force
	return r
}
// Is authentication required to perform this operation
func (r ApiDeletePartitionedTopicNPRequest) Authoritative(authoritative bool) ApiDeletePartitionedTopicNPRequest {
	r.authoritative = &authoritative
	return r
}
// Delete the topic&#39;s schema storage
func (r ApiDeletePartitionedTopicNPRequest) DeleteSchema(deleteSchema bool) ApiDeletePartitionedTopicNPRequest {
	r.deleteSchema = &deleteSchema
	return r
}

func (r ApiDeletePartitionedTopicNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeletePartitionedTopicNPExecute(r)
}

/*
DeletePartitionedTopicNP Delete a partitioned topic.

It will also delete all the partitions of the topic if it exists.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiDeletePartitionedTopicNPRequest
*/
func (a *NonPersistentTopicApiService) DeletePartitionedTopicNP(ctx _context.Context, tenant string, namespace string, topic string) ApiDeletePartitionedTopicNPRequest {
	return ApiDeletePartitionedTopicNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) DeletePartitionedTopicNPExecute(r ApiDeletePartitionedTopicNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.DeletePartitionedTopicNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/partitions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	if r.deleteSchema != nil {
		localVarQueryParams.Add("deleteSchema", parameterToString(*r.deleteSchema, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSubscriptionNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	subName string
	force *bool
	authoritative *bool
}

// Disconnect and close all consumers and delete subscription forcefully
func (r ApiDeleteSubscriptionNPRequest) Force(force bool) ApiDeleteSubscriptionNPRequest {
	r.force = &force
	return r
}
// Is authentication required to perform this operation
func (r ApiDeleteSubscriptionNPRequest) Authoritative(authoritative bool) ApiDeleteSubscriptionNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiDeleteSubscriptionNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteSubscriptionNPExecute(r)
}

/*
DeleteSubscriptionNP Delete a subscription.

The subscription cannot be deleted if delete is not forcefully and there are any active consumers attached to it. Force delete ignores connected consumers and deletes subscription by explicitly closing them.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param subName Subscription to be deleted
 @return ApiDeleteSubscriptionNPRequest
*/
func (a *NonPersistentTopicApiService) DeleteSubscriptionNP(ctx _context.Context, tenant string, namespace string, topic string, subName string) ApiDeleteSubscriptionNPRequest {
	return ApiDeleteSubscriptionNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		subName: subName,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) DeleteSubscriptionNPExecute(r ApiDeleteSubscriptionNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.DeleteSubscriptionNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.PathEscape(parameterToString(r.subName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTopicNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	force *bool
	authoritative *bool
	deleteSchema *bool
}

// Stop all producer/consumer/replicator and delete topic forcefully
func (r ApiDeleteTopicNPRequest) Force(force bool) ApiDeleteTopicNPRequest {
	r.force = &force
	return r
}
// Is authentication required to perform this operation
func (r ApiDeleteTopicNPRequest) Authoritative(authoritative bool) ApiDeleteTopicNPRequest {
	r.authoritative = &authoritative
	return r
}
// Delete the topic&#39;s schema storage
func (r ApiDeleteTopicNPRequest) DeleteSchema(deleteSchema bool) ApiDeleteTopicNPRequest {
	r.deleteSchema = &deleteSchema
	return r
}

func (r ApiDeleteTopicNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteTopicNPExecute(r)
}

/*
DeleteTopicNP Delete a topic.

The topic cannot be deleted if delete is not forcefully and there's any active subscription or producer connected to the it. Force delete ignores connected clients and deletes topic by explicitly closing them.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiDeleteTopicNPRequest
*/
func (a *NonPersistentTopicApiService) DeleteTopicNP(ctx _context.Context, tenant string, namespace string, topic string) ApiDeleteTopicNPRequest {
	return ApiDeleteTopicNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) DeleteTopicNPExecute(r ApiDeleteTopicNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.DeleteTopicNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	if r.deleteSchema != nil {
		localVarQueryParams.Add("deleteSchema", parameterToString(*r.deleteSchema, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExamineMessageNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	initialPosition *string
	messagePosition *int64
	authoritative *bool
}

// Relative start position to examine message.It can be &#39;latest&#39; or &#39;earliest&#39;
func (r ApiExamineMessageNPRequest) InitialPosition(initialPosition string) ApiExamineMessageNPRequest {
	r.initialPosition = &initialPosition
	return r
}
// The position of messages (default 1)
func (r ApiExamineMessageNPRequest) MessagePosition(messagePosition int64) ApiExamineMessageNPRequest {
	r.messagePosition = &messagePosition
	return r
}
// Is authentication required to perform this operation
func (r ApiExamineMessageNPRequest) Authoritative(authoritative bool) ApiExamineMessageNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiExamineMessageNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ExamineMessageNPExecute(r)
}

/*
ExamineMessageNP Examine a specific message on a topic by position relative to the earliest or the latest message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiExamineMessageNPRequest
*/
func (a *NonPersistentTopicApiService) ExamineMessageNP(ctx _context.Context, tenant string, namespace string, topic string) ApiExamineMessageNPRequest {
	return ApiExamineMessageNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) ExamineMessageNPExecute(r ApiExamineMessageNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.ExamineMessageNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/examinemessage"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.initialPosition != nil {
		localVarQueryParams.Add("initialPosition", parameterToString(*r.initialPosition, ""))
	}
	if r.messagePosition != nil {
		localVarQueryParams.Add("messagePosition", parameterToString(*r.messagePosition, ""))
	}
	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExpireMessagesForAllSubscriptionsNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	expireTimeInSeconds int32
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiExpireMessagesForAllSubscriptionsNPRequest) Authoritative(authoritative bool) ApiExpireMessagesForAllSubscriptionsNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiExpireMessagesForAllSubscriptionsNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ExpireMessagesForAllSubscriptionsNPExecute(r)
}

/*
ExpireMessagesForAllSubscriptionsNP Expiry messages on all subscriptions of topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param expireTimeInSeconds Expires beyond the specified number of seconds
 @return ApiExpireMessagesForAllSubscriptionsNPRequest
*/
func (a *NonPersistentTopicApiService) ExpireMessagesForAllSubscriptionsNP(ctx _context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32) ApiExpireMessagesForAllSubscriptionsNPRequest {
	return ApiExpireMessagesForAllSubscriptionsNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		expireTimeInSeconds: expireTimeInSeconds,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) ExpireMessagesForAllSubscriptionsNPExecute(r ApiExpireMessagesForAllSubscriptionsNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.ExpireMessagesForAllSubscriptionsNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/all_subscription/expireMessages/{expireTimeInSeconds}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"expireTimeInSeconds"+"}", _neturl.PathEscape(parameterToString(r.expireTimeInSeconds, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExpireTopicMessagesNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	subName string
	expireTimeInSeconds int32
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiExpireTopicMessagesNPRequest) Authoritative(authoritative bool) ApiExpireTopicMessagesNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiExpireTopicMessagesNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ExpireTopicMessagesNPExecute(r)
}

/*
ExpireTopicMessagesNP Expiry messages on a topic subscription.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param subName Subscription to be Expiry messages on
 @param expireTimeInSeconds Expires beyond the specified number of seconds
 @return ApiExpireTopicMessagesNPRequest
*/
func (a *NonPersistentTopicApiService) ExpireTopicMessagesNP(ctx _context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32) ApiExpireTopicMessagesNPRequest {
	return ApiExpireTopicMessagesNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		subName: subName,
		expireTimeInSeconds: expireTimeInSeconds,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) ExpireTopicMessagesNPExecute(r ApiExpireTopicMessagesNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.ExpireTopicMessagesNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/expireMessages/{expireTimeInSeconds}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.PathEscape(parameterToString(r.subName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"expireTimeInSeconds"+"}", _neturl.PathEscape(parameterToString(r.expireTimeInSeconds, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBacklogNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiGetBacklogNPRequest) Authoritative(authoritative bool) ApiGetBacklogNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiGetBacklogNPRequest) Execute() (PersistentOfflineTopicStats, *_nethttp.Response, error) {
	return r.ApiService.GetBacklogNPExecute(r)
}

/*
GetBacklogNP Get estimated backlog for offline topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiGetBacklogNPRequest
*/
func (a *NonPersistentTopicApiService) GetBacklogNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetBacklogNPRequest {
	return ApiGetBacklogNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return PersistentOfflineTopicStats
func (a *NonPersistentTopicApiService) GetBacklogNPExecute(r ApiGetBacklogNPRequest) (PersistentOfflineTopicStats, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersistentOfflineTopicStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetBacklogNP")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/backlog"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBacklogQuotaMapNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetBacklogQuotaMapNPRequest) Execute() (map[string]map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GetBacklogQuotaMapNPExecute(r)
}

/*
GetBacklogQuotaMapNP Get backlog quota map on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetBacklogQuotaMapNPRequest
*/
func (a *NonPersistentTopicApiService) GetBacklogQuotaMapNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetBacklogQuotaMapNPRequest {
	return ApiGetBacklogQuotaMapNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return map[string]map[string]interface{}
func (a *NonPersistentTopicApiService) GetBacklogQuotaMapNPExecute(r ApiGetBacklogQuotaMapNPRequest) (map[string]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetBacklogQuotaMapNP")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/backlogQuotaMap"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCompactionThresholdNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetCompactionThresholdNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetCompactionThresholdNPExecute(r)
}

/*
GetCompactionThresholdNP Get compaction threshold configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetCompactionThresholdNPRequest
*/
func (a *NonPersistentTopicApiService) GetCompactionThresholdNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetCompactionThresholdNPRequest {
	return ApiGetCompactionThresholdNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetCompactionThresholdNPExecute(r ApiGetCompactionThresholdNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetCompactionThresholdNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/compactionThreshold"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDeduplicationEnabledNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetDeduplicationEnabledNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetDeduplicationEnabledNPExecute(r)
}

/*
GetDeduplicationEnabledNP Get deduplication configuration of a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetDeduplicationEnabledNPRequest
*/
func (a *NonPersistentTopicApiService) GetDeduplicationEnabledNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetDeduplicationEnabledNPRequest {
	return ApiGetDeduplicationEnabledNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetDeduplicationEnabledNPExecute(r ApiGetDeduplicationEnabledNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetDeduplicationEnabledNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDeduplicationSnapshotIntervalNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetDeduplicationSnapshotIntervalNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetDeduplicationSnapshotIntervalNPExecute(r)
}

/*
GetDeduplicationSnapshotIntervalNP Get deduplicationSnapshotInterval config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetDeduplicationSnapshotIntervalNPRequest
*/
func (a *NonPersistentTopicApiService) GetDeduplicationSnapshotIntervalNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetDeduplicationSnapshotIntervalNPRequest {
	return ApiGetDeduplicationSnapshotIntervalNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetDeduplicationSnapshotIntervalNPExecute(r ApiGetDeduplicationSnapshotIntervalNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetDeduplicationSnapshotIntervalNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDelayedDeliveryPoliciesNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetDelayedDeliveryPoliciesNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetDelayedDeliveryPoliciesNPExecute(r)
}

/*
GetDelayedDeliveryPoliciesNP Get delayed delivery messages config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetDelayedDeliveryPoliciesNPRequest
*/
func (a *NonPersistentTopicApiService) GetDelayedDeliveryPoliciesNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetDelayedDeliveryPoliciesNPRequest {
	return ApiGetDelayedDeliveryPoliciesNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetDelayedDeliveryPoliciesNPExecute(r ApiGetDelayedDeliveryPoliciesNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetDelayedDeliveryPoliciesNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/delayedDelivery"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDispatchRateNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetDispatchRateNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetDispatchRateNPExecute(r)
}

/*
GetDispatchRateNP Get dispatch rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetDispatchRateNPRequest
*/
func (a *NonPersistentTopicApiService) GetDispatchRateNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetDispatchRateNPRequest {
	return ApiGetDispatchRateNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetDispatchRateNPExecute(r ApiGetDispatchRateNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetDispatchRateNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/dispatchRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetInactiveTopicPoliciesNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetInactiveTopicPoliciesNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetInactiveTopicPoliciesNPExecute(r)
}

/*
GetInactiveTopicPoliciesNP Get inactive topic policies on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetInactiveTopicPoliciesNPRequest
*/
func (a *NonPersistentTopicApiService) GetInactiveTopicPoliciesNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetInactiveTopicPoliciesNPRequest {
	return ApiGetInactiveTopicPoliciesNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetInactiveTopicPoliciesNPExecute(r ApiGetInactiveTopicPoliciesNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetInactiveTopicPoliciesNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetInternalStatsNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
	metadata *bool
}

// Is authentication required to perform this operation
func (r ApiGetInternalStatsNPRequest) Authoritative(authoritative bool) ApiGetInternalStatsNPRequest {
	r.authoritative = &authoritative
	return r
}
func (r ApiGetInternalStatsNPRequest) Metadata(metadata bool) ApiGetInternalStatsNPRequest {
	r.metadata = &metadata
	return r
}

func (r ApiGetInternalStatsNPRequest) Execute() (PersistentTopicInternalStats, *_nethttp.Response, error) {
	return r.ApiService.GetInternalStatsNPExecute(r)
}

/*
GetInternalStatsNP Get the internal stats for the topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiGetInternalStatsNPRequest
*/
func (a *NonPersistentTopicApiService) GetInternalStatsNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetInternalStatsNPRequest {
	return ApiGetInternalStatsNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return PersistentTopicInternalStats
func (a *NonPersistentTopicApiService) GetInternalStatsNPExecute(r ApiGetInternalStatsNPRequest) (PersistentTopicInternalStats, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersistentTopicInternalStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetInternalStatsNP")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/internalStats"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	if r.metadata != nil {
		localVarQueryParams.Add("metadata", parameterToString(*r.metadata, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLastMessageIdNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiGetLastMessageIdNPRequest) Authoritative(authoritative bool) ApiGetLastMessageIdNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiGetLastMessageIdNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetLastMessageIdNPExecute(r)
}

/*
GetLastMessageIdNP Return the last commit message id of topic

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiGetLastMessageIdNPRequest
*/
func (a *NonPersistentTopicApiService) GetLastMessageIdNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetLastMessageIdNPRequest {
	return ApiGetLastMessageIdNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetLastMessageIdNPExecute(r ApiGetLastMessageIdNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetLastMessageIdNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/lastMessageId"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetListFromBundleRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	bundle string
}


func (r ApiGetListFromBundleRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GetListFromBundleExecute(r)
}

/*
GetListFromBundle Get the list of non-persistent topics under a namespace bundle.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param bundle Bundle range of a topic
 @return ApiGetListFromBundleRequest
*/
func (a *NonPersistentTopicApiService) GetListFromBundle(ctx _context.Context, tenant string, namespace string, bundle string) ApiGetListFromBundleRequest {
	return ApiGetListFromBundleRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		bundle: bundle,
	}
}

// Execute executes the request
//  @return []string
func (a *NonPersistentTopicApiService) GetListFromBundleExecute(r ApiGetListFromBundleRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetListFromBundle")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{bundle}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bundle"+"}", _neturl.PathEscape(parameterToString(r.bundle, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
}


func (r ApiGetListNPRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GetListNPExecute(r)
}

/*
GetListNP Get the list of non-persistent topics under a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @return ApiGetListNPRequest
*/
func (a *NonPersistentTopicApiService) GetListNP(ctx _context.Context, tenant string, namespace string) ApiGetListNPRequest {
	return ApiGetListNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return []string
func (a *NonPersistentTopicApiService) GetListNPExecute(r ApiGetListNPRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetListNP")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagedLedgerInfoNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiGetManagedLedgerInfoNPRequest) Authoritative(authoritative bool) ApiGetManagedLedgerInfoNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiGetManagedLedgerInfoNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetManagedLedgerInfoNPExecute(r)
}

/*
GetManagedLedgerInfoNP Get the stored topic metadata.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiGetManagedLedgerInfoNPRequest
*/
func (a *NonPersistentTopicApiService) GetManagedLedgerInfoNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetManagedLedgerInfoNPRequest {
	return ApiGetManagedLedgerInfoNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetManagedLedgerInfoNPExecute(r ApiGetManagedLedgerInfoNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetManagedLedgerInfoNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/internal-info"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMaxConsumersNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetMaxConsumersNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetMaxConsumersNPExecute(r)
}

/*
GetMaxConsumersNP Get maxConsumers config for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetMaxConsumersNPRequest
*/
func (a *NonPersistentTopicApiService) GetMaxConsumersNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetMaxConsumersNPRequest {
	return ApiGetMaxConsumersNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetMaxConsumersNPExecute(r ApiGetMaxConsumersNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetMaxConsumersNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/maxConsumers"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMaxConsumersPerSubscriptionNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetMaxConsumersPerSubscriptionNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetMaxConsumersPerSubscriptionNPExecute(r)
}

/*
GetMaxConsumersPerSubscriptionNP Get max consumers per subscription configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetMaxConsumersPerSubscriptionNPRequest
*/
func (a *NonPersistentTopicApiService) GetMaxConsumersPerSubscriptionNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetMaxConsumersPerSubscriptionNPRequest {
	return ApiGetMaxConsumersPerSubscriptionNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetMaxConsumersPerSubscriptionNPExecute(r ApiGetMaxConsumersPerSubscriptionNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetMaxConsumersPerSubscriptionNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMaxProducersNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetMaxProducersNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetMaxProducersNPExecute(r)
}

/*
GetMaxProducersNP Get maxProducers config for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetMaxProducersNPRequest
*/
func (a *NonPersistentTopicApiService) GetMaxProducersNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetMaxProducersNPRequest {
	return ApiGetMaxProducersNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetMaxProducersNPExecute(r ApiGetMaxProducersNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetMaxProducersNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/maxProducers"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMaxUnackedMessagesOnConsumerNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetMaxUnackedMessagesOnConsumerNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetMaxUnackedMessagesOnConsumerNPExecute(r)
}

/*
GetMaxUnackedMessagesOnConsumerNP Get max unacked messages per consumer config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetMaxUnackedMessagesOnConsumerNPRequest
*/
func (a *NonPersistentTopicApiService) GetMaxUnackedMessagesOnConsumerNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetMaxUnackedMessagesOnConsumerNPRequest {
	return ApiGetMaxUnackedMessagesOnConsumerNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetMaxUnackedMessagesOnConsumerNPExecute(r ApiGetMaxUnackedMessagesOnConsumerNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetMaxUnackedMessagesOnConsumerNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMaxUnackedMessagesOnSubscriptionNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetMaxUnackedMessagesOnSubscriptionNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetMaxUnackedMessagesOnSubscriptionNPExecute(r)
}

/*
GetMaxUnackedMessagesOnSubscriptionNP Get max unacked messages per subscription config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetMaxUnackedMessagesOnSubscriptionNPRequest
*/
func (a *NonPersistentTopicApiService) GetMaxUnackedMessagesOnSubscriptionNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetMaxUnackedMessagesOnSubscriptionNPRequest {
	return ApiGetMaxUnackedMessagesOnSubscriptionNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetMaxUnackedMessagesOnSubscriptionNPExecute(r ApiGetMaxUnackedMessagesOnSubscriptionNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetMaxUnackedMessagesOnSubscriptionNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMessageByIdNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	ledgerId int64
	entryId int64
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiGetMessageByIdNPRequest) Authoritative(authoritative bool) ApiGetMessageByIdNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiGetMessageByIdNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetMessageByIdNPExecute(r)
}

/*
GetMessageByIdNP Get message by its messageId.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param ledgerId The ledger id
 @param entryId The entry id
 @return ApiGetMessageByIdNPRequest
*/
func (a *NonPersistentTopicApiService) GetMessageByIdNP(ctx _context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64) ApiGetMessageByIdNPRequest {
	return ApiGetMessageByIdNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		ledgerId: ledgerId,
		entryId: entryId,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetMessageByIdNPExecute(r ApiGetMessageByIdNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetMessageByIdNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/ledger/{ledgerId}/entry/{entryId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ledgerId"+"}", _neturl.PathEscape(parameterToString(r.ledgerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entryId"+"}", _neturl.PathEscape(parameterToString(r.entryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMessageTTLNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetMessageTTLNPRequest) Execute() (int32, *_nethttp.Response, error) {
	return r.ApiService.GetMessageTTLNPExecute(r)
}

/*
GetMessageTTLNP Get message TTL in seconds for a topic

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetMessageTTLNPRequest
*/
func (a *NonPersistentTopicApiService) GetMessageTTLNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetMessageTTLNPRequest {
	return ApiGetMessageTTLNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return int32
func (a *NonPersistentTopicApiService) GetMessageTTLNPExecute(r ApiGetMessageTTLNPRequest) (int32, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetMessageTTLNP")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/messageTTL"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOffloadPoliciesNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetOffloadPoliciesNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetOffloadPoliciesNPExecute(r)
}

/*
GetOffloadPoliciesNP Get offload policies on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetOffloadPoliciesNPRequest
*/
func (a *NonPersistentTopicApiService) GetOffloadPoliciesNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetOffloadPoliciesNPRequest {
	return ApiGetOffloadPoliciesNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetOffloadPoliciesNPExecute(r ApiGetOffloadPoliciesNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetOffloadPoliciesNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/offloadPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPartitionedMetadataNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
	checkAllowAutoCreation *bool
}

// Is authentication required to perform this operation
func (r ApiGetPartitionedMetadataNPRequest) Authoritative(authoritative bool) ApiGetPartitionedMetadataNPRequest {
	r.authoritative = &authoritative
	return r
}
// Is check configuration required to automatically create topic
func (r ApiGetPartitionedMetadataNPRequest) CheckAllowAutoCreation(checkAllowAutoCreation bool) ApiGetPartitionedMetadataNPRequest {
	r.checkAllowAutoCreation = &checkAllowAutoCreation
	return r
}

func (r ApiGetPartitionedMetadataNPRequest) Execute() (PartitionedTopicMetadata, *_nethttp.Response, error) {
	return r.ApiService.GetPartitionedMetadataNPExecute(r)
}

/*
GetPartitionedMetadataNP Get partitioned topic metadata.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiGetPartitionedMetadataNPRequest
*/
func (a *NonPersistentTopicApiService) GetPartitionedMetadataNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetPartitionedMetadataNPRequest {
	return ApiGetPartitionedMetadataNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return PartitionedTopicMetadata
func (a *NonPersistentTopicApiService) GetPartitionedMetadataNPExecute(r ApiGetPartitionedMetadataNPRequest) (PartitionedTopicMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PartitionedTopicMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetPartitionedMetadataNP")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/partitions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	if r.checkAllowAutoCreation != nil {
		localVarQueryParams.Add("checkAllowAutoCreation", parameterToString(*r.checkAllowAutoCreation, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartitionedStatsNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	perPartition *bool
	authoritative *bool
	getPreciseBacklog *bool
}

// Get per partition stats
func (r ApiGetPartitionedStatsNPRequest) PerPartition(perPartition bool) ApiGetPartitionedStatsNPRequest {
	r.perPartition = &perPartition
	return r
}
// Is authentication required to perform this operation
func (r ApiGetPartitionedStatsNPRequest) Authoritative(authoritative bool) ApiGetPartitionedStatsNPRequest {
	r.authoritative = &authoritative
	return r
}
// Is return precise backlog or imprecise backlog
func (r ApiGetPartitionedStatsNPRequest) GetPreciseBacklog(getPreciseBacklog bool) ApiGetPartitionedStatsNPRequest {
	r.getPreciseBacklog = &getPreciseBacklog
	return r
}

func (r ApiGetPartitionedStatsNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetPartitionedStatsNPExecute(r)
}

/*
GetPartitionedStatsNP Get the stats for the partitioned topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiGetPartitionedStatsNPRequest
*/
func (a *NonPersistentTopicApiService) GetPartitionedStatsNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetPartitionedStatsNPRequest {
	return ApiGetPartitionedStatsNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetPartitionedStatsNPExecute(r ApiGetPartitionedStatsNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetPartitionedStatsNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/partitioned-stats"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.perPartition != nil {
		localVarQueryParams.Add("perPartition", parameterToString(*r.perPartition, ""))
	}
	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	if r.getPreciseBacklog != nil {
		localVarQueryParams.Add("getPreciseBacklog", parameterToString(*r.getPreciseBacklog, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPartitionedTopicListNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
}


func (r ApiGetPartitionedTopicListNPRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GetPartitionedTopicListNPExecute(r)
}

/*
GetPartitionedTopicListNP Get the list of partitioned topics under a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @return ApiGetPartitionedTopicListNPRequest
*/
func (a *NonPersistentTopicApiService) GetPartitionedTopicListNP(ctx _context.Context, tenant string, namespace string) ApiGetPartitionedTopicListNPRequest {
	return ApiGetPartitionedTopicListNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return []string
func (a *NonPersistentTopicApiService) GetPartitionedTopicListNPExecute(r ApiGetPartitionedTopicListNPRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetPartitionedTopicListNP")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/partitioned"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPermissionsOnTopicNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetPermissionsOnTopicNPRequest) Execute() (map[string]map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GetPermissionsOnTopicNPExecute(r)
}

/*
GetPermissionsOnTopicNP Get permissions on a topic.

Retrieve the effective permissions for a topic. These permissions are defined by the permissions set at thenamespace level combined (union) with any eventual specific permission set on the topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiGetPermissionsOnTopicNPRequest
*/
func (a *NonPersistentTopicApiService) GetPermissionsOnTopicNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetPermissionsOnTopicNPRequest {
	return ApiGetPermissionsOnTopicNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return map[string]map[string]interface{}
func (a *NonPersistentTopicApiService) GetPermissionsOnTopicNPExecute(r ApiGetPermissionsOnTopicNPRequest) (map[string]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetPermissionsOnTopicNP")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPersistenceNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetPersistenceNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetPersistenceNPExecute(r)
}

/*
GetPersistenceNP Get configuration of persistence policies for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetPersistenceNPRequest
*/
func (a *NonPersistentTopicApiService) GetPersistenceNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetPersistenceNPRequest {
	return ApiGetPersistenceNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetPersistenceNPExecute(r ApiGetPersistenceNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetPersistenceNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/persistence"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPublishRateNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetPublishRateNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetPublishRateNPExecute(r)
}

/*
GetPublishRateNP Get publish rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetPublishRateNPRequest
*/
func (a *NonPersistentTopicApiService) GetPublishRateNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetPublishRateNPRequest {
	return ApiGetPublishRateNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetPublishRateNPExecute(r ApiGetPublishRateNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetPublishRateNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/publishRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRetentionNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetRetentionNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetRetentionNPExecute(r)
}

/*
GetRetentionNP Get retention configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetRetentionNPRequest
*/
func (a *NonPersistentTopicApiService) GetRetentionNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetRetentionNPRequest {
	return ApiGetRetentionNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetRetentionNPExecute(r ApiGetRetentionNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetRetentionNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/retention"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetStatsNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
	getPreciseBacklog *bool
}

// Is authentication required to perform this operation
func (r ApiGetStatsNPRequest) Authoritative(authoritative bool) ApiGetStatsNPRequest {
	r.authoritative = &authoritative
	return r
}
// Is return precise backlog or imprecise backlog
func (r ApiGetStatsNPRequest) GetPreciseBacklog(getPreciseBacklog bool) ApiGetStatsNPRequest {
	r.getPreciseBacklog = &getPreciseBacklog
	return r
}

func (r ApiGetStatsNPRequest) Execute() (TopicStats, *_nethttp.Response, error) {
	return r.ApiService.GetStatsNPExecute(r)
}

/*
GetStatsNP Get the stats for the topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiGetStatsNPRequest
*/
func (a *NonPersistentTopicApiService) GetStatsNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetStatsNPRequest {
	return ApiGetStatsNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return TopicStats
func (a *NonPersistentTopicApiService) GetStatsNPExecute(r ApiGetStatsNPRequest) (TopicStats, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TopicStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetStatsNP")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	if r.getPreciseBacklog != nil {
		localVarQueryParams.Add("getPreciseBacklog", parameterToString(*r.getPreciseBacklog, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubscribeRateNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetSubscribeRateNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetSubscribeRateNPExecute(r)
}

/*
GetSubscribeRateNP Get subscribe rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetSubscribeRateNPRequest
*/
func (a *NonPersistentTopicApiService) GetSubscribeRateNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetSubscribeRateNPRequest {
	return ApiGetSubscribeRateNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetSubscribeRateNPExecute(r ApiGetSubscribeRateNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetSubscribeRateNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscribeRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSubscriptionDispatchRateNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetSubscriptionDispatchRateNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetSubscriptionDispatchRateNPExecute(r)
}

/*
GetSubscriptionDispatchRateNP Get subscription message dispatch rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetSubscriptionDispatchRateNPRequest
*/
func (a *NonPersistentTopicApiService) GetSubscriptionDispatchRateNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetSubscriptionDispatchRateNPRequest {
	return ApiGetSubscriptionDispatchRateNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetSubscriptionDispatchRateNPExecute(r ApiGetSubscriptionDispatchRateNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetSubscriptionDispatchRateNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSubscriptionsNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiGetSubscriptionsNPRequest) Authoritative(authoritative bool) ApiGetSubscriptionsNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiGetSubscriptionsNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetSubscriptionsNPExecute(r)
}

/*
GetSubscriptionsNP Get the list of persistent subscriptions for a given topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiGetSubscriptionsNPRequest
*/
func (a *NonPersistentTopicApiService) GetSubscriptionsNP(ctx _context.Context, tenant string, namespace string, topic string) ApiGetSubscriptionsNPRequest {
	return ApiGetSubscriptionsNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GetSubscriptionsNPExecute(r ApiGetSubscriptionsNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GetSubscriptionsNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGrantPermissionsOnTopicNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	role string
	body *[]string
}

// Actions to be granted (produce,functions,consume)
func (r ApiGrantPermissionsOnTopicNPRequest) Body(body []string) ApiGrantPermissionsOnTopicNPRequest {
	r.body = &body
	return r
}

func (r ApiGrantPermissionsOnTopicNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GrantPermissionsOnTopicNPExecute(r)
}

/*
GrantPermissionsOnTopicNP Grant a new permission to a role on a single topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param role Client role to which grant permissions
 @return ApiGrantPermissionsOnTopicNPRequest
*/
func (a *NonPersistentTopicApiService) GrantPermissionsOnTopicNP(ctx _context.Context, tenant string, namespace string, topic string, role string) ApiGrantPermissionsOnTopicNPRequest {
	return ApiGrantPermissionsOnTopicNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		role: role,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) GrantPermissionsOnTopicNPExecute(r ApiGrantPermissionsOnTopicNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.GrantPermissionsOnTopicNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/permissions/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", _neturl.PathEscape(parameterToString(r.role, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOffloadStatusNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiOffloadStatusNPRequest) Authoritative(authoritative bool) ApiOffloadStatusNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiOffloadStatusNPRequest) Execute() (OffloadProcessStatus, *_nethttp.Response, error) {
	return r.ApiService.OffloadStatusNPExecute(r)
}

/*
OffloadStatusNP Offload a prefix of a topic to long term storage

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiOffloadStatusNPRequest
*/
func (a *NonPersistentTopicApiService) OffloadStatusNP(ctx _context.Context, tenant string, namespace string, topic string) ApiOffloadStatusNPRequest {
	return ApiOffloadStatusNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return OffloadProcessStatus
func (a *NonPersistentTopicApiService) OffloadStatusNPExecute(r ApiOffloadStatusNPRequest) (OffloadProcessStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OffloadProcessStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.OffloadStatusNP")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/offload"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPeekNthMessageNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	subName string
	messagePosition int32
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiPeekNthMessageNPRequest) Authoritative(authoritative bool) ApiPeekNthMessageNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiPeekNthMessageNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PeekNthMessageNPExecute(r)
}

/*
PeekNthMessageNP Peek nth message on a topic subscription.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param subName Subscribed message expired
 @param messagePosition The number of messages (default 1)
 @return ApiPeekNthMessageNPRequest
*/
func (a *NonPersistentTopicApiService) PeekNthMessageNP(ctx _context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32) ApiPeekNthMessageNPRequest {
	return ApiPeekNthMessageNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		subName: subName,
		messagePosition: messagePosition,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) PeekNthMessageNPExecute(r ApiPeekNthMessageNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.PeekNthMessageNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/position/{messagePosition}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.PathEscape(parameterToString(r.subName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"messagePosition"+"}", _neturl.PathEscape(parameterToString(r.messagePosition, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveBacklogQuotaNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	backlogQuotaType *string
}

func (r ApiRemoveBacklogQuotaNPRequest) BacklogQuotaType(backlogQuotaType string) ApiRemoveBacklogQuotaNPRequest {
	r.backlogQuotaType = &backlogQuotaType
	return r
}

func (r ApiRemoveBacklogQuotaNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveBacklogQuotaNPExecute(r)
}

/*
RemoveBacklogQuotaNP Remove a backlog quota policy from a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveBacklogQuotaNPRequest
*/
func (a *NonPersistentTopicApiService) RemoveBacklogQuotaNP(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveBacklogQuotaNPRequest {
	return ApiRemoveBacklogQuotaNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) RemoveBacklogQuotaNPExecute(r ApiRemoveBacklogQuotaNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.RemoveBacklogQuotaNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/backlogQuota"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.backlogQuotaType != nil {
		localVarQueryParams.Add("backlogQuotaType", parameterToString(*r.backlogQuotaType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveCompactionThresholdNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveCompactionThresholdNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveCompactionThresholdNPExecute(r)
}

/*
RemoveCompactionThresholdNP Remove compaction threshold configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveCompactionThresholdNPRequest
*/
func (a *NonPersistentTopicApiService) RemoveCompactionThresholdNP(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveCompactionThresholdNPRequest {
	return ApiRemoveCompactionThresholdNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) RemoveCompactionThresholdNPExecute(r ApiRemoveCompactionThresholdNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.RemoveCompactionThresholdNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/compactionThreshold"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveDeduplicationEnabledNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveDeduplicationEnabledNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveDeduplicationEnabledNPExecute(r)
}

/*
RemoveDeduplicationEnabledNP Remove deduplication configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveDeduplicationEnabledNPRequest
*/
func (a *NonPersistentTopicApiService) RemoveDeduplicationEnabledNP(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveDeduplicationEnabledNPRequest {
	return ApiRemoveDeduplicationEnabledNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) RemoveDeduplicationEnabledNPExecute(r ApiRemoveDeduplicationEnabledNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.RemoveDeduplicationEnabledNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveDispatchRateNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveDispatchRateNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveDispatchRateNPExecute(r)
}

/*
RemoveDispatchRateNP Remove message dispatch rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveDispatchRateNPRequest
*/
func (a *NonPersistentTopicApiService) RemoveDispatchRateNP(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveDispatchRateNPRequest {
	return ApiRemoveDispatchRateNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) RemoveDispatchRateNPExecute(r ApiRemoveDispatchRateNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.RemoveDispatchRateNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/dispatchRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveMaxConsumersNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveMaxConsumersNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveMaxConsumersNPExecute(r)
}

/*
RemoveMaxConsumersNP Remove maxConsumers config for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveMaxConsumersNPRequest
*/
func (a *NonPersistentTopicApiService) RemoveMaxConsumersNP(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveMaxConsumersNPRequest {
	return ApiRemoveMaxConsumersNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) RemoveMaxConsumersNPExecute(r ApiRemoveMaxConsumersNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.RemoveMaxConsumersNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/maxConsumers"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveMaxConsumersPerSubscriptionNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveMaxConsumersPerSubscriptionNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveMaxConsumersPerSubscriptionNPExecute(r)
}

/*
RemoveMaxConsumersPerSubscriptionNP Remove max consumers per subscription configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveMaxConsumersPerSubscriptionNPRequest
*/
func (a *NonPersistentTopicApiService) RemoveMaxConsumersPerSubscriptionNP(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveMaxConsumersPerSubscriptionNPRequest {
	return ApiRemoveMaxConsumersPerSubscriptionNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) RemoveMaxConsumersPerSubscriptionNPExecute(r ApiRemoveMaxConsumersPerSubscriptionNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.RemoveMaxConsumersPerSubscriptionNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveMaxProducersNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveMaxProducersNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveMaxProducersNPExecute(r)
}

/*
RemoveMaxProducersNP Remove maxProducers config for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveMaxProducersNPRequest
*/
func (a *NonPersistentTopicApiService) RemoveMaxProducersNP(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveMaxProducersNPRequest {
	return ApiRemoveMaxProducersNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) RemoveMaxProducersNPExecute(r ApiRemoveMaxProducersNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.RemoveMaxProducersNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/maxProducers"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveMessageTTLNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveMessageTTLNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveMessageTTLNPExecute(r)
}

/*
RemoveMessageTTLNP Remove message TTL in seconds for a topic

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveMessageTTLNPRequest
*/
func (a *NonPersistentTopicApiService) RemoveMessageTTLNP(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveMessageTTLNPRequest {
	return ApiRemoveMessageTTLNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) RemoveMessageTTLNPExecute(r ApiRemoveMessageTTLNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.RemoveMessageTTLNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/messageTTL"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveOffloadPoliciesNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveOffloadPoliciesNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveOffloadPoliciesNPExecute(r)
}

/*
RemoveOffloadPoliciesNP Delete offload policies on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveOffloadPoliciesNPRequest
*/
func (a *NonPersistentTopicApiService) RemoveOffloadPoliciesNP(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveOffloadPoliciesNPRequest {
	return ApiRemoveOffloadPoliciesNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) RemoveOffloadPoliciesNPExecute(r ApiRemoveOffloadPoliciesNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.RemoveOffloadPoliciesNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/offloadPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemovePersistenceNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemovePersistenceNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemovePersistenceNPExecute(r)
}

/*
RemovePersistenceNP Remove configuration of persistence policies for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemovePersistenceNPRequest
*/
func (a *NonPersistentTopicApiService) RemovePersistenceNP(ctx _context.Context, tenant string, namespace string, topic string) ApiRemovePersistenceNPRequest {
	return ApiRemovePersistenceNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) RemovePersistenceNPExecute(r ApiRemovePersistenceNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.RemovePersistenceNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/persistence"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemovePublishRateNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemovePublishRateNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemovePublishRateNPExecute(r)
}

/*
RemovePublishRateNP Remove message publish rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemovePublishRateNPRequest
*/
func (a *NonPersistentTopicApiService) RemovePublishRateNP(ctx _context.Context, tenant string, namespace string, topic string) ApiRemovePublishRateNPRequest {
	return ApiRemovePublishRateNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) RemovePublishRateNPExecute(r ApiRemovePublishRateNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.RemovePublishRateNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/publishRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveRetentionNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveRetentionNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveRetentionNPExecute(r)
}

/*
RemoveRetentionNP Remove retention configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveRetentionNPRequest
*/
func (a *NonPersistentTopicApiService) RemoveRetentionNP(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveRetentionNPRequest {
	return ApiRemoveRetentionNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) RemoveRetentionNPExecute(r ApiRemoveRetentionNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.RemoveRetentionNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/retention"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveSubscribeRateNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveSubscribeRateNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveSubscribeRateNPExecute(r)
}

/*
RemoveSubscribeRateNP Remove subscribe rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveSubscribeRateNPRequest
*/
func (a *NonPersistentTopicApiService) RemoveSubscribeRateNP(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveSubscribeRateNPRequest {
	return ApiRemoveSubscribeRateNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) RemoveSubscribeRateNPExecute(r ApiRemoveSubscribeRateNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.RemoveSubscribeRateNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscribeRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveSubscriptionDispatchRateNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveSubscriptionDispatchRateNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveSubscriptionDispatchRateNPExecute(r)
}

/*
RemoveSubscriptionDispatchRateNP Remove subscription message dispatch rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveSubscriptionDispatchRateNPRequest
*/
func (a *NonPersistentTopicApiService) RemoveSubscriptionDispatchRateNP(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveSubscriptionDispatchRateNPRequest {
	return ApiRemoveSubscriptionDispatchRateNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) RemoveSubscriptionDispatchRateNPExecute(r ApiRemoveSubscriptionDispatchRateNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.RemoveSubscriptionDispatchRateNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiResetCursorNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	subName string
	timestamp int64
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiResetCursorNPRequest) Authoritative(authoritative bool) ApiResetCursorNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiResetCursorNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ResetCursorNPExecute(r)
}

/*
ResetCursorNP Reset subscription to message position closest to absolute timestamp (in ms).

It fence cursor and disconnects all active consumers before reseting cursor.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param subName Subscription to reset position on
 @param timestamp time in minutes to reset back to (or minutes, hours,days,weeks eg:100m, 3h, 2d, 5w)
 @return ApiResetCursorNPRequest
*/
func (a *NonPersistentTopicApiService) ResetCursorNP(ctx _context.Context, tenant string, namespace string, topic string, subName string, timestamp int64) ApiResetCursorNPRequest {
	return ApiResetCursorNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		subName: subName,
		timestamp: timestamp,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) ResetCursorNPExecute(r ApiResetCursorNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.ResetCursorNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor/{timestamp}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.PathEscape(parameterToString(r.subName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timestamp"+"}", _neturl.PathEscape(parameterToString(r.timestamp, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiResetCursorOnPositionNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	subName string
	authoritative *bool
	messageId *ResetCursorData
}

// Is authentication required to perform this operation
func (r ApiResetCursorOnPositionNPRequest) Authoritative(authoritative bool) ApiResetCursorOnPositionNPRequest {
	r.authoritative = &authoritative
	return r
}
// messageId to reset back to (ledgerId:entryId)
func (r ApiResetCursorOnPositionNPRequest) MessageId(messageId ResetCursorData) ApiResetCursorOnPositionNPRequest {
	r.messageId = &messageId
	return r
}

func (r ApiResetCursorOnPositionNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ResetCursorOnPositionNPExecute(r)
}

/*
ResetCursorOnPositionNP Reset subscription to message position closest to given position.

It fence cursor and disconnects all active consumers before reseting cursor.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param subName Subscription to reset position on
 @return ApiResetCursorOnPositionNPRequest
*/
func (a *NonPersistentTopicApiService) ResetCursorOnPositionNP(ctx _context.Context, tenant string, namespace string, topic string, subName string) ApiResetCursorOnPositionNPRequest {
	return ApiResetCursorOnPositionNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		subName: subName,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) ResetCursorOnPositionNPExecute(r ApiResetCursorOnPositionNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.ResetCursorOnPositionNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.PathEscape(parameterToString(r.subName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.messageId
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRevokePermissionsOnTopicNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	role string
}


func (r ApiRevokePermissionsOnTopicNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RevokePermissionsOnTopicNPExecute(r)
}

/*
RevokePermissionsOnTopicNP Revoke permissions on a topic.

Revoke permissions to a role on a single topic. If the permission was not set at the topiclevel, but rather at the namespace level, this operation will return an error (HTTP status code 412).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param role Client role to which grant permissions
 @return ApiRevokePermissionsOnTopicNPRequest
*/
func (a *NonPersistentTopicApiService) RevokePermissionsOnTopicNP(ctx _context.Context, tenant string, namespace string, topic string, role string) ApiRevokePermissionsOnTopicNPRequest {
	return ApiRevokePermissionsOnTopicNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		role: role,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) RevokePermissionsOnTopicNPExecute(r ApiRevokePermissionsOnTopicNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.RevokePermissionsOnTopicNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/permissions/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", _neturl.PathEscape(parameterToString(r.role, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetBacklogQuotaNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	backlogQuotaType *string
}

func (r ApiSetBacklogQuotaNPRequest) BacklogQuotaType(backlogQuotaType string) ApiSetBacklogQuotaNPRequest {
	r.backlogQuotaType = &backlogQuotaType
	return r
}

func (r ApiSetBacklogQuotaNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetBacklogQuotaNPExecute(r)
}

/*
SetBacklogQuotaNP Set a backlog quota for a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetBacklogQuotaNPRequest
*/
func (a *NonPersistentTopicApiService) SetBacklogQuotaNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetBacklogQuotaNPRequest {
	return ApiSetBacklogQuotaNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetBacklogQuotaNPExecute(r ApiSetBacklogQuotaNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetBacklogQuotaNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/backlogQuota"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.backlogQuotaType != nil {
		localVarQueryParams.Add("backlogQuotaType", parameterToString(*r.backlogQuotaType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetCompactionThresholdNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *int64
}

// Dispatch rate for the specified topic
func (r ApiSetCompactionThresholdNPRequest) Body(body int64) ApiSetCompactionThresholdNPRequest {
	r.body = &body
	return r
}

func (r ApiSetCompactionThresholdNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetCompactionThresholdNPExecute(r)
}

/*
SetCompactionThresholdNP Set compaction threshold configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetCompactionThresholdNPRequest
*/
func (a *NonPersistentTopicApiService) SetCompactionThresholdNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetCompactionThresholdNPRequest {
	return ApiSetCompactionThresholdNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetCompactionThresholdNPExecute(r ApiSetCompactionThresholdNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetCompactionThresholdNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/compactionThreshold"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetDeduplicationEnabledNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *bool
}

// DeduplicationEnabled policies for the specified topic
func (r ApiSetDeduplicationEnabledNPRequest) Body(body bool) ApiSetDeduplicationEnabledNPRequest {
	r.body = &body
	return r
}

func (r ApiSetDeduplicationEnabledNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetDeduplicationEnabledNPExecute(r)
}

/*
SetDeduplicationEnabledNP Set deduplication enabled on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetDeduplicationEnabledNPRequest
*/
func (a *NonPersistentTopicApiService) SetDeduplicationEnabledNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetDeduplicationEnabledNPRequest {
	return ApiSetDeduplicationEnabledNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetDeduplicationEnabledNPExecute(r ApiSetDeduplicationEnabledNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetDeduplicationEnabledNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetDeduplicationSnapshotIntervalNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *int32
}

// Interval to take deduplication snapshot for the specified topic
func (r ApiSetDeduplicationSnapshotIntervalNPRequest) Body(body int32) ApiSetDeduplicationSnapshotIntervalNPRequest {
	r.body = &body
	return r
}

func (r ApiSetDeduplicationSnapshotIntervalNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetDeduplicationSnapshotIntervalNPExecute(r)
}

/*
SetDeduplicationSnapshotIntervalNP Set deduplicationSnapshotInterval config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetDeduplicationSnapshotIntervalNPRequest
*/
func (a *NonPersistentTopicApiService) SetDeduplicationSnapshotIntervalNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetDeduplicationSnapshotIntervalNPRequest {
	return ApiSetDeduplicationSnapshotIntervalNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetDeduplicationSnapshotIntervalNPExecute(r ApiSetDeduplicationSnapshotIntervalNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetDeduplicationSnapshotIntervalNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetDelayedDeliveryPoliciesNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *DelayedDeliveryPolicies
}

// Delayed delivery policies for the specified topic
func (r ApiSetDelayedDeliveryPoliciesNPRequest) Body(body DelayedDeliveryPolicies) ApiSetDelayedDeliveryPoliciesNPRequest {
	r.body = &body
	return r
}

func (r ApiSetDelayedDeliveryPoliciesNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetDelayedDeliveryPoliciesNPExecute(r)
}

/*
SetDelayedDeliveryPoliciesNP Set delayed delivery messages config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetDelayedDeliveryPoliciesNPRequest
*/
func (a *NonPersistentTopicApiService) SetDelayedDeliveryPoliciesNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetDelayedDeliveryPoliciesNPRequest {
	return ApiSetDelayedDeliveryPoliciesNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetDelayedDeliveryPoliciesNPExecute(r ApiSetDelayedDeliveryPoliciesNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetDelayedDeliveryPoliciesNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/delayedDelivery"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetDispatchRateNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *DispatchRate
}

// Dispatch rate for the specified topic
func (r ApiSetDispatchRateNPRequest) Body(body DispatchRate) ApiSetDispatchRateNPRequest {
	r.body = &body
	return r
}

func (r ApiSetDispatchRateNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetDispatchRateNPExecute(r)
}

/*
SetDispatchRateNP Set message dispatch rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetDispatchRateNPRequest
*/
func (a *NonPersistentTopicApiService) SetDispatchRateNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetDispatchRateNPRequest {
	return ApiSetDispatchRateNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetDispatchRateNPExecute(r ApiSetDispatchRateNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetDispatchRateNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/dispatchRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetInactiveTopicPoliciesNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *InactiveTopicPolicies
}

// inactive topic policies for the specified topic
func (r ApiSetInactiveTopicPoliciesNPRequest) Body(body InactiveTopicPolicies) ApiSetInactiveTopicPoliciesNPRequest {
	r.body = &body
	return r
}

func (r ApiSetInactiveTopicPoliciesNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetInactiveTopicPoliciesNPExecute(r)
}

/*
SetInactiveTopicPoliciesNP Set inactive topic policies on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetInactiveTopicPoliciesNPRequest
*/
func (a *NonPersistentTopicApiService) SetInactiveTopicPoliciesNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetInactiveTopicPoliciesNPRequest {
	return ApiSetInactiveTopicPoliciesNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetInactiveTopicPoliciesNPExecute(r ApiSetInactiveTopicPoliciesNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetInactiveTopicPoliciesNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetMaxConsumersNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *int32
}

// The max consumers of the topic
func (r ApiSetMaxConsumersNPRequest) Body(body int32) ApiSetMaxConsumersNPRequest {
	r.body = &body
	return r
}

func (r ApiSetMaxConsumersNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetMaxConsumersNPExecute(r)
}

/*
SetMaxConsumersNP Set maxConsumers config for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetMaxConsumersNPRequest
*/
func (a *NonPersistentTopicApiService) SetMaxConsumersNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetMaxConsumersNPRequest {
	return ApiSetMaxConsumersNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetMaxConsumersNPExecute(r ApiSetMaxConsumersNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetMaxConsumersNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/maxConsumers"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetMaxConsumersPerSubscriptionNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *int32
}

// Dispatch rate for the specified topic
func (r ApiSetMaxConsumersPerSubscriptionNPRequest) Body(body int32) ApiSetMaxConsumersPerSubscriptionNPRequest {
	r.body = &body
	return r
}

func (r ApiSetMaxConsumersPerSubscriptionNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetMaxConsumersPerSubscriptionNPExecute(r)
}

/*
SetMaxConsumersPerSubscriptionNP Set max consumers per subscription configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetMaxConsumersPerSubscriptionNPRequest
*/
func (a *NonPersistentTopicApiService) SetMaxConsumersPerSubscriptionNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetMaxConsumersPerSubscriptionNPRequest {
	return ApiSetMaxConsumersPerSubscriptionNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetMaxConsumersPerSubscriptionNPExecute(r ApiSetMaxConsumersPerSubscriptionNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetMaxConsumersPerSubscriptionNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetMaxProducersNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *int32
}

// The max producers of the topic
func (r ApiSetMaxProducersNPRequest) Body(body int32) ApiSetMaxProducersNPRequest {
	r.body = &body
	return r
}

func (r ApiSetMaxProducersNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetMaxProducersNPExecute(r)
}

/*
SetMaxProducersNP Set maxProducers config for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetMaxProducersNPRequest
*/
func (a *NonPersistentTopicApiService) SetMaxProducersNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetMaxProducersNPRequest {
	return ApiSetMaxProducersNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetMaxProducersNPExecute(r ApiSetMaxProducersNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetMaxProducersNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/maxProducers"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetMaxUnackedMessagesOnConsumerNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *int32
}

// Max unacked messages on consumer policies for the specified topic
func (r ApiSetMaxUnackedMessagesOnConsumerNPRequest) Body(body int32) ApiSetMaxUnackedMessagesOnConsumerNPRequest {
	r.body = &body
	return r
}

func (r ApiSetMaxUnackedMessagesOnConsumerNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetMaxUnackedMessagesOnConsumerNPExecute(r)
}

/*
SetMaxUnackedMessagesOnConsumerNP Set max unacked messages per consumer config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetMaxUnackedMessagesOnConsumerNPRequest
*/
func (a *NonPersistentTopicApiService) SetMaxUnackedMessagesOnConsumerNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetMaxUnackedMessagesOnConsumerNPRequest {
	return ApiSetMaxUnackedMessagesOnConsumerNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetMaxUnackedMessagesOnConsumerNPExecute(r ApiSetMaxUnackedMessagesOnConsumerNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetMaxUnackedMessagesOnConsumerNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetMaxUnackedMessagesOnSubscriptionNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *int32
}

// Max unacked messages on subscription policies for the specified topic
func (r ApiSetMaxUnackedMessagesOnSubscriptionNPRequest) Body(body int32) ApiSetMaxUnackedMessagesOnSubscriptionNPRequest {
	r.body = &body
	return r
}

func (r ApiSetMaxUnackedMessagesOnSubscriptionNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetMaxUnackedMessagesOnSubscriptionNPExecute(r)
}

/*
SetMaxUnackedMessagesOnSubscriptionNP Set max unacked messages per subscription config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetMaxUnackedMessagesOnSubscriptionNPRequest
*/
func (a *NonPersistentTopicApiService) SetMaxUnackedMessagesOnSubscriptionNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetMaxUnackedMessagesOnSubscriptionNPRequest {
	return ApiSetMaxUnackedMessagesOnSubscriptionNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetMaxUnackedMessagesOnSubscriptionNPExecute(r ApiSetMaxUnackedMessagesOnSubscriptionNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetMaxUnackedMessagesOnSubscriptionNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetMessageTTLNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	messageTTL *int32
}

// TTL in seconds for the specified namespace
func (r ApiSetMessageTTLNPRequest) MessageTTL(messageTTL int32) ApiSetMessageTTLNPRequest {
	r.messageTTL = &messageTTL
	return r
}

func (r ApiSetMessageTTLNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetMessageTTLNPExecute(r)
}

/*
SetMessageTTLNP Set message TTL in seconds for a topic

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetMessageTTLNPRequest
*/
func (a *NonPersistentTopicApiService) SetMessageTTLNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetMessageTTLNPRequest {
	return ApiSetMessageTTLNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetMessageTTLNPExecute(r ApiSetMessageTTLNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetMessageTTLNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/messageTTL"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.messageTTL == nil {
		return nil, reportError("messageTTL is required and must be specified")
	}

	localVarQueryParams.Add("messageTTL", parameterToString(*r.messageTTL, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetOffloadPoliciesNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *OffloadPolicies
}

// Offload policies for the specified topic
func (r ApiSetOffloadPoliciesNPRequest) Body(body OffloadPolicies) ApiSetOffloadPoliciesNPRequest {
	r.body = &body
	return r
}

func (r ApiSetOffloadPoliciesNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetOffloadPoliciesNPExecute(r)
}

/*
SetOffloadPoliciesNP Set offload policies on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetOffloadPoliciesNPRequest
*/
func (a *NonPersistentTopicApiService) SetOffloadPoliciesNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetOffloadPoliciesNPRequest {
	return ApiSetOffloadPoliciesNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetOffloadPoliciesNPExecute(r ApiSetOffloadPoliciesNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetOffloadPoliciesNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/offloadPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetPersistenceNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *PersistencePolicies
}

// Bookkeeper persistence policies for specified topic
func (r ApiSetPersistenceNPRequest) Body(body PersistencePolicies) ApiSetPersistenceNPRequest {
	r.body = &body
	return r
}

func (r ApiSetPersistenceNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetPersistenceNPExecute(r)
}

/*
SetPersistenceNP Set configuration of persistence policies for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetPersistenceNPRequest
*/
func (a *NonPersistentTopicApiService) SetPersistenceNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetPersistenceNPRequest {
	return ApiSetPersistenceNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetPersistenceNPExecute(r ApiSetPersistenceNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetPersistenceNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/persistence"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetPublishRateNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *PublishRate
}

// Dispatch rate for the specified topic
func (r ApiSetPublishRateNPRequest) Body(body PublishRate) ApiSetPublishRateNPRequest {
	r.body = &body
	return r
}

func (r ApiSetPublishRateNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetPublishRateNPExecute(r)
}

/*
SetPublishRateNP Set message publish rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetPublishRateNPRequest
*/
func (a *NonPersistentTopicApiService) SetPublishRateNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetPublishRateNPRequest {
	return ApiSetPublishRateNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetPublishRateNPExecute(r ApiSetPublishRateNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetPublishRateNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/publishRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetRetentionNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *RetentionPolicies
}

// Retention policies for the specified namespace
func (r ApiSetRetentionNPRequest) Body(body RetentionPolicies) ApiSetRetentionNPRequest {
	r.body = &body
	return r
}

func (r ApiSetRetentionNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetRetentionNPExecute(r)
}

/*
SetRetentionNP Set retention configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetRetentionNPRequest
*/
func (a *NonPersistentTopicApiService) SetRetentionNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetRetentionNPRequest {
	return ApiSetRetentionNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetRetentionNPExecute(r ApiSetRetentionNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetRetentionNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/retention"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetSubscribeRateNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *SubscribeRate
}

// Subscribe rate for the specified topic
func (r ApiSetSubscribeRateNPRequest) Body(body SubscribeRate) ApiSetSubscribeRateNPRequest {
	r.body = &body
	return r
}

func (r ApiSetSubscribeRateNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetSubscribeRateNPExecute(r)
}

/*
SetSubscribeRateNP Set subscribe rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetSubscribeRateNPRequest
*/
func (a *NonPersistentTopicApiService) SetSubscribeRateNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetSubscribeRateNPRequest {
	return ApiSetSubscribeRateNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetSubscribeRateNPExecute(r ApiSetSubscribeRateNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetSubscribeRateNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscribeRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetSubscriptionDispatchRateNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *DispatchRate
}

// Subscription message dispatch rate for the specified topic
func (r ApiSetSubscriptionDispatchRateNPRequest) Body(body DispatchRate) ApiSetSubscriptionDispatchRateNPRequest {
	r.body = &body
	return r
}

func (r ApiSetSubscriptionDispatchRateNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetSubscriptionDispatchRateNPExecute(r)
}

/*
SetSubscriptionDispatchRateNP Set subscription message dispatch rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetSubscriptionDispatchRateNPRequest
*/
func (a *NonPersistentTopicApiService) SetSubscriptionDispatchRateNP(ctx _context.Context, tenant string, namespace string, topic string) ApiSetSubscriptionDispatchRateNPRequest {
	return ApiSetSubscriptionDispatchRateNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SetSubscriptionDispatchRateNPExecute(r ApiSetSubscriptionDispatchRateNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SetSubscriptionDispatchRateNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSkipAllMessagesNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	subName string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiSkipAllMessagesNPRequest) Authoritative(authoritative bool) ApiSkipAllMessagesNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiSkipAllMessagesNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SkipAllMessagesNPExecute(r)
}

/*
SkipAllMessagesNP Skip all messages on a topic subscription.

Completely clears the backlog on the subscription.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param subName Name of subscription
 @return ApiSkipAllMessagesNPRequest
*/
func (a *NonPersistentTopicApiService) SkipAllMessagesNP(ctx _context.Context, tenant string, namespace string, topic string, subName string) ApiSkipAllMessagesNPRequest {
	return ApiSkipAllMessagesNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		subName: subName,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SkipAllMessagesNPExecute(r ApiSkipAllMessagesNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SkipAllMessagesNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip_all"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.PathEscape(parameterToString(r.subName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSkipMessagesNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	subName string
	numMessages int32
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiSkipMessagesNPRequest) Authoritative(authoritative bool) ApiSkipMessagesNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiSkipMessagesNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SkipMessagesNPExecute(r)
}

/*
SkipMessagesNP Skipping messages on a topic subscription.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param subName Name of subscription
 @param numMessages The number of messages to skip
 @return ApiSkipMessagesNPRequest
*/
func (a *NonPersistentTopicApiService) SkipMessagesNP(ctx _context.Context, tenant string, namespace string, topic string, subName string, numMessages int32) ApiSkipMessagesNPRequest {
	return ApiSkipMessagesNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		subName: subName,
		numMessages: numMessages,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) SkipMessagesNPExecute(r ApiSkipMessagesNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.SkipMessagesNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip/{numMessages}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.PathEscape(parameterToString(r.subName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"numMessages"+"}", _neturl.PathEscape(parameterToString(r.numMessages, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTriggerOffloadNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiTriggerOffloadNPRequest) Authoritative(authoritative bool) ApiTriggerOffloadNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiTriggerOffloadNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TriggerOffloadNPExecute(r)
}

/*
TriggerOffloadNP Offload a prefix of a topic to long term storage

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiTriggerOffloadNPRequest
*/
func (a *NonPersistentTopicApiService) TriggerOffloadNP(ctx _context.Context, tenant string, namespace string, topic string) ApiTriggerOffloadNPRequest {
	return ApiTriggerOffloadNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) TriggerOffloadNPExecute(r ApiTriggerOffloadNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.TriggerOffloadNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/offload"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnloadTopicNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiUnloadTopicNPRequest) Authoritative(authoritative bool) ApiUnloadTopicNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiUnloadTopicNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UnloadTopicNPExecute(r)
}

/*
UnloadTopicNP Unload a topic

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiUnloadTopicNPRequest
*/
func (a *NonPersistentTopicApiService) UnloadTopicNP(ctx _context.Context, tenant string, namespace string, topic string) ApiUnloadTopicNPRequest {
	return ApiUnloadTopicNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) UnloadTopicNPExecute(r ApiUnloadTopicNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.UnloadTopicNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/unload"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdatePartitionedTopicNPRequest struct {
	ctx _context.Context
	ApiService *NonPersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *int32
	updateLocalTopicOnly *bool
	authoritative *bool
}

// The number of partitions for the topic
func (r ApiUpdatePartitionedTopicNPRequest) Body(body int32) ApiUpdatePartitionedTopicNPRequest {
	r.body = &body
	return r
}
func (r ApiUpdatePartitionedTopicNPRequest) UpdateLocalTopicOnly(updateLocalTopicOnly bool) ApiUpdatePartitionedTopicNPRequest {
	r.updateLocalTopicOnly = &updateLocalTopicOnly
	return r
}
// Is authentication required to perform this operation
func (r ApiUpdatePartitionedTopicNPRequest) Authoritative(authoritative bool) ApiUpdatePartitionedTopicNPRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiUpdatePartitionedTopicNPRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdatePartitionedTopicNPExecute(r)
}

/*
UpdatePartitionedTopicNP Increment partitions of an existing partitioned topic.

It only increments partitions of existing non-global partitioned-topic

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiUpdatePartitionedTopicNPRequest
*/
func (a *NonPersistentTopicApiService) UpdatePartitionedTopicNP(ctx _context.Context, tenant string, namespace string, topic string) ApiUpdatePartitionedTopicNPRequest {
	return ApiUpdatePartitionedTopicNPRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *NonPersistentTopicApiService) UpdatePartitionedTopicNPExecute(r ApiUpdatePartitionedTopicNPRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonPersistentTopicApiService.UpdatePartitionedTopicNP")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/non-persistent/{tenant}/{namespace}/{topic}/partitions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.updateLocalTopicOnly != nil {
		localVarQueryParams.Add("updateLocalTopicOnly", parameterToString(*r.updateLocalTopicOnly, ""))
	}
	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
