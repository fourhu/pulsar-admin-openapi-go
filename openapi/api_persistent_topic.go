/*
Pulsar Admin REST API

This provides the REST API for admin operations

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// PersistentTopicApiService PersistentTopicApi service
type PersistentTopicApiService service

type ApiCompactRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiCompactRequest) Authoritative(authoritative bool) ApiCompactRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiCompactRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CompactExecute(r)
}

/*
Compact Trigger a compaction operation on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiCompactRequest
*/
func (a *PersistentTopicApiService) Compact(ctx _context.Context, tenant string, namespace string, topic string) ApiCompactRequest {
	return ApiCompactRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) CompactExecute(r ApiCompactRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.Compact")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/compaction"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompactionStatusRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiCompactionStatusRequest) Authoritative(authoritative bool) ApiCompactionStatusRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiCompactionStatusRequest) Execute() (LongRunningProcessStatus, *_nethttp.Response, error) {
	return r.ApiService.CompactionStatusExecute(r)
}

/*
CompactionStatus Get the status of a compaction operation for a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiCompactionStatusRequest
*/
func (a *PersistentTopicApiService) CompactionStatus(ctx _context.Context, tenant string, namespace string, topic string) ApiCompactionStatusRequest {
	return ApiCompactionStatusRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return LongRunningProcessStatus
func (a *PersistentTopicApiService) CompactionStatusExecute(r ApiCompactionStatusRequest) (LongRunningProcessStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LongRunningProcessStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.CompactionStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/compaction"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateMissedPartitionsRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiCreateMissedPartitionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateMissedPartitionsExecute(r)
}

/*
CreateMissedPartitions Create missed partitions of an existing partitioned topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiCreateMissedPartitionsRequest
*/
func (a *PersistentTopicApiService) CreateMissedPartitions(ctx _context.Context, tenant string, namespace string, topic string) ApiCreateMissedPartitionsRequest {
	return ApiCreateMissedPartitionsRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) CreateMissedPartitionsExecute(r ApiCreateMissedPartitionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.CreateMissedPartitions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/createMissedPartitions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateNonPartitionedTopicRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiCreateNonPartitionedTopicRequest) Authoritative(authoritative bool) ApiCreateNonPartitionedTopicRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiCreateNonPartitionedTopicRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateNonPartitionedTopicExecute(r)
}

/*
CreateNonPartitionedTopic Create a non-partitioned topic.

This is the only REST endpoint from which non-partitioned topics could be created.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiCreateNonPartitionedTopicRequest
*/
func (a *PersistentTopicApiService) CreateNonPartitionedTopic(ctx _context.Context, tenant string, namespace string, topic string) ApiCreateNonPartitionedTopicRequest {
	return ApiCreateNonPartitionedTopicRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) CreateNonPartitionedTopicExecute(r ApiCreateNonPartitionedTopicRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.CreateNonPartitionedTopic")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreatePartitionedTopicRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *int32
}

// The number of partitions for the topic
func (r ApiCreatePartitionedTopicRequest) Body(body int32) ApiCreatePartitionedTopicRequest {
	r.body = &body
	return r
}

func (r ApiCreatePartitionedTopicRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreatePartitionedTopicExecute(r)
}

/*
CreatePartitionedTopic Create a partitioned topic.

It needs to be called before creating a producer on a partitioned topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiCreatePartitionedTopicRequest
*/
func (a *PersistentTopicApiService) CreatePartitionedTopic(ctx _context.Context, tenant string, namespace string, topic string) ApiCreatePartitionedTopicRequest {
	return ApiCreatePartitionedTopicRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) CreatePartitionedTopicExecute(r ApiCreatePartitionedTopicRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.CreatePartitionedTopic")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/partitions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateSubscriptionRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	subscriptionName string
	authoritative *bool
	replicated *bool
	messageId *MessageIdImpl
}

// Is authentication required to perform this operation
func (r ApiCreateSubscriptionRequest) Authoritative(authoritative bool) ApiCreateSubscriptionRequest {
	r.authoritative = &authoritative
	return r
}
// Is replicated required to perform this operation
func (r ApiCreateSubscriptionRequest) Replicated(replicated bool) ApiCreateSubscriptionRequest {
	r.replicated = &replicated
	return r
}
// messageId where to create the subscription. It can be &#39;latest&#39;, &#39;earliest&#39; or (ledgerId:entryId)
func (r ApiCreateSubscriptionRequest) MessageId(messageId MessageIdImpl) ApiCreateSubscriptionRequest {
	r.messageId = &messageId
	return r
}

func (r ApiCreateSubscriptionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateSubscriptionExecute(r)
}

/*
CreateSubscription Create a subscription on the topic.

Creates a subscription on the topic at the specified message id

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param subscriptionName Subscription to create position on
 @return ApiCreateSubscriptionRequest
*/
func (a *PersistentTopicApiService) CreateSubscription(ctx _context.Context, tenant string, namespace string, topic string, subscriptionName string) ApiCreateSubscriptionRequest {
	return ApiCreateSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		subscriptionName: subscriptionName,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) CreateSubscriptionExecute(r ApiCreateSubscriptionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.CreateSubscription")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/subscription/{subscriptionName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriptionName"+"}", _neturl.PathEscape(parameterToString(r.subscriptionName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	if r.replicated != nil {
		localVarQueryParams.Add("replicated", parameterToString(*r.replicated, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.messageId
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDeduplicationSnapshotIntervalRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiDeleteDeduplicationSnapshotIntervalRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteDeduplicationSnapshotIntervalExecute(r)
}

/*
DeleteDeduplicationSnapshotInterval Delete deduplicationSnapshotInterval config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiDeleteDeduplicationSnapshotIntervalRequest
*/
func (a *PersistentTopicApiService) DeleteDeduplicationSnapshotInterval(ctx _context.Context, tenant string, namespace string, topic string) ApiDeleteDeduplicationSnapshotIntervalRequest {
	return ApiDeleteDeduplicationSnapshotIntervalRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) DeleteDeduplicationSnapshotIntervalExecute(r ApiDeleteDeduplicationSnapshotIntervalRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.DeleteDeduplicationSnapshotInterval")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDelayedDeliveryPoliciesRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiDeleteDelayedDeliveryPoliciesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteDelayedDeliveryPoliciesExecute(r)
}

/*
DeleteDelayedDeliveryPolicies Set delayed delivery messages config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiDeleteDelayedDeliveryPoliciesRequest
*/
func (a *PersistentTopicApiService) DeleteDelayedDeliveryPolicies(ctx _context.Context, tenant string, namespace string, topic string) ApiDeleteDelayedDeliveryPoliciesRequest {
	return ApiDeleteDelayedDeliveryPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) DeleteDelayedDeliveryPoliciesExecute(r ApiDeleteDelayedDeliveryPoliciesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.DeleteDelayedDeliveryPolicies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/delayedDelivery"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteInactiveTopicPoliciesRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiDeleteInactiveTopicPoliciesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteInactiveTopicPoliciesExecute(r)
}

/*
DeleteInactiveTopicPolicies Delete inactive topic policies on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiDeleteInactiveTopicPoliciesRequest
*/
func (a *PersistentTopicApiService) DeleteInactiveTopicPolicies(ctx _context.Context, tenant string, namespace string, topic string) ApiDeleteInactiveTopicPoliciesRequest {
	return ApiDeleteInactiveTopicPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) DeleteInactiveTopicPoliciesExecute(r ApiDeleteInactiveTopicPoliciesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.DeleteInactiveTopicPolicies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteMaxUnackedMessagesOnConsumerRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiDeleteMaxUnackedMessagesOnConsumerRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteMaxUnackedMessagesOnConsumerExecute(r)
}

/*
DeleteMaxUnackedMessagesOnConsumer Delete max unacked messages per consumer config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiDeleteMaxUnackedMessagesOnConsumerRequest
*/
func (a *PersistentTopicApiService) DeleteMaxUnackedMessagesOnConsumer(ctx _context.Context, tenant string, namespace string, topic string) ApiDeleteMaxUnackedMessagesOnConsumerRequest {
	return ApiDeleteMaxUnackedMessagesOnConsumerRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) DeleteMaxUnackedMessagesOnConsumerExecute(r ApiDeleteMaxUnackedMessagesOnConsumerRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.DeleteMaxUnackedMessagesOnConsumer")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteMaxUnackedMessagesOnSubscriptionRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiDeleteMaxUnackedMessagesOnSubscriptionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteMaxUnackedMessagesOnSubscriptionExecute(r)
}

/*
DeleteMaxUnackedMessagesOnSubscription Delete max unacked messages per subscription config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiDeleteMaxUnackedMessagesOnSubscriptionRequest
*/
func (a *PersistentTopicApiService) DeleteMaxUnackedMessagesOnSubscription(ctx _context.Context, tenant string, namespace string, topic string) ApiDeleteMaxUnackedMessagesOnSubscriptionRequest {
	return ApiDeleteMaxUnackedMessagesOnSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) DeleteMaxUnackedMessagesOnSubscriptionExecute(r ApiDeleteMaxUnackedMessagesOnSubscriptionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.DeleteMaxUnackedMessagesOnSubscription")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePartitionedTopicRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	force *bool
	authoritative *bool
	deleteSchema *bool
}

// Stop all producer/consumer/replicator and delete topic forcefully
func (r ApiDeletePartitionedTopicRequest) Force(force bool) ApiDeletePartitionedTopicRequest {
	r.force = &force
	return r
}
// Is authentication required to perform this operation
func (r ApiDeletePartitionedTopicRequest) Authoritative(authoritative bool) ApiDeletePartitionedTopicRequest {
	r.authoritative = &authoritative
	return r
}
// Delete the topic&#39;s schema storage
func (r ApiDeletePartitionedTopicRequest) DeleteSchema(deleteSchema bool) ApiDeletePartitionedTopicRequest {
	r.deleteSchema = &deleteSchema
	return r
}

func (r ApiDeletePartitionedTopicRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeletePartitionedTopicExecute(r)
}

/*
DeletePartitionedTopic Delete a partitioned topic.

It will also delete all the partitions of the topic if it exists.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiDeletePartitionedTopicRequest
*/
func (a *PersistentTopicApiService) DeletePartitionedTopic(ctx _context.Context, tenant string, namespace string, topic string) ApiDeletePartitionedTopicRequest {
	return ApiDeletePartitionedTopicRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) DeletePartitionedTopicExecute(r ApiDeletePartitionedTopicRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.DeletePartitionedTopic")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/partitions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	if r.deleteSchema != nil {
		localVarQueryParams.Add("deleteSchema", parameterToString(*r.deleteSchema, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSubscriptionRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	subName string
	force *bool
	authoritative *bool
}

// Disconnect and close all consumers and delete subscription forcefully
func (r ApiDeleteSubscriptionRequest) Force(force bool) ApiDeleteSubscriptionRequest {
	r.force = &force
	return r
}
// Is authentication required to perform this operation
func (r ApiDeleteSubscriptionRequest) Authoritative(authoritative bool) ApiDeleteSubscriptionRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiDeleteSubscriptionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteSubscriptionExecute(r)
}

/*
DeleteSubscription Delete a subscription.

The subscription cannot be deleted if delete is not forcefully and there are any active consumers attached to it. Force delete ignores connected consumers and deletes subscription by explicitly closing them.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param subName Subscription to be deleted
 @return ApiDeleteSubscriptionRequest
*/
func (a *PersistentTopicApiService) DeleteSubscription(ctx _context.Context, tenant string, namespace string, topic string, subName string) ApiDeleteSubscriptionRequest {
	return ApiDeleteSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		subName: subName,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) DeleteSubscriptionExecute(r ApiDeleteSubscriptionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.DeleteSubscription")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.PathEscape(parameterToString(r.subName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTopicRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	force *bool
	authoritative *bool
	deleteSchema *bool
}

// Stop all producer/consumer/replicator and delete topic forcefully
func (r ApiDeleteTopicRequest) Force(force bool) ApiDeleteTopicRequest {
	r.force = &force
	return r
}
// Is authentication required to perform this operation
func (r ApiDeleteTopicRequest) Authoritative(authoritative bool) ApiDeleteTopicRequest {
	r.authoritative = &authoritative
	return r
}
// Delete the topic&#39;s schema storage
func (r ApiDeleteTopicRequest) DeleteSchema(deleteSchema bool) ApiDeleteTopicRequest {
	r.deleteSchema = &deleteSchema
	return r
}

func (r ApiDeleteTopicRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteTopicExecute(r)
}

/*
DeleteTopic Delete a topic.

The topic cannot be deleted if delete is not forcefully and there's any active subscription or producer connected to the it. Force delete ignores connected clients and deletes topic by explicitly closing them.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiDeleteTopicRequest
*/
func (a *PersistentTopicApiService) DeleteTopic(ctx _context.Context, tenant string, namespace string, topic string) ApiDeleteTopicRequest {
	return ApiDeleteTopicRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) DeleteTopicExecute(r ApiDeleteTopicRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.DeleteTopic")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	if r.deleteSchema != nil {
		localVarQueryParams.Add("deleteSchema", parameterToString(*r.deleteSchema, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExamineMessageRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	initialPosition *string
	messagePosition *int64
	authoritative *bool
}

// Relative start position to examine message.It can be &#39;latest&#39; or &#39;earliest&#39;
func (r ApiExamineMessageRequest) InitialPosition(initialPosition string) ApiExamineMessageRequest {
	r.initialPosition = &initialPosition
	return r
}
// The position of messages (default 1)
func (r ApiExamineMessageRequest) MessagePosition(messagePosition int64) ApiExamineMessageRequest {
	r.messagePosition = &messagePosition
	return r
}
// Is authentication required to perform this operation
func (r ApiExamineMessageRequest) Authoritative(authoritative bool) ApiExamineMessageRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiExamineMessageRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ExamineMessageExecute(r)
}

/*
ExamineMessage Examine a specific message on a topic by position relative to the earliest or the latest message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiExamineMessageRequest
*/
func (a *PersistentTopicApiService) ExamineMessage(ctx _context.Context, tenant string, namespace string, topic string) ApiExamineMessageRequest {
	return ApiExamineMessageRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) ExamineMessageExecute(r ApiExamineMessageRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.ExamineMessage")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/examinemessage"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.initialPosition != nil {
		localVarQueryParams.Add("initialPosition", parameterToString(*r.initialPosition, ""))
	}
	if r.messagePosition != nil {
		localVarQueryParams.Add("messagePosition", parameterToString(*r.messagePosition, ""))
	}
	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExpireMessagesForAllSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	expireTimeInSeconds int32
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiExpireMessagesForAllSubscriptionsRequest) Authoritative(authoritative bool) ApiExpireMessagesForAllSubscriptionsRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiExpireMessagesForAllSubscriptionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ExpireMessagesForAllSubscriptionsExecute(r)
}

/*
ExpireMessagesForAllSubscriptions Expiry messages on all subscriptions of topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param expireTimeInSeconds Expires beyond the specified number of seconds
 @return ApiExpireMessagesForAllSubscriptionsRequest
*/
func (a *PersistentTopicApiService) ExpireMessagesForAllSubscriptions(ctx _context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32) ApiExpireMessagesForAllSubscriptionsRequest {
	return ApiExpireMessagesForAllSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		expireTimeInSeconds: expireTimeInSeconds,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) ExpireMessagesForAllSubscriptionsExecute(r ApiExpireMessagesForAllSubscriptionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.ExpireMessagesForAllSubscriptions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/all_subscription/expireMessages/{expireTimeInSeconds}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"expireTimeInSeconds"+"}", _neturl.PathEscape(parameterToString(r.expireTimeInSeconds, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExpireTopicMessagesRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	subName string
	expireTimeInSeconds int32
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiExpireTopicMessagesRequest) Authoritative(authoritative bool) ApiExpireTopicMessagesRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiExpireTopicMessagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ExpireTopicMessagesExecute(r)
}

/*
ExpireTopicMessages Expiry messages on a topic subscription.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param subName Subscription to be Expiry messages on
 @param expireTimeInSeconds Expires beyond the specified number of seconds
 @return ApiExpireTopicMessagesRequest
*/
func (a *PersistentTopicApiService) ExpireTopicMessages(ctx _context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32) ApiExpireTopicMessagesRequest {
	return ApiExpireTopicMessagesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		subName: subName,
		expireTimeInSeconds: expireTimeInSeconds,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) ExpireTopicMessagesExecute(r ApiExpireTopicMessagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.ExpireTopicMessages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/expireMessages/{expireTimeInSeconds}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.PathEscape(parameterToString(r.subName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"expireTimeInSeconds"+"}", _neturl.PathEscape(parameterToString(r.expireTimeInSeconds, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBacklogRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiGetBacklogRequest) Authoritative(authoritative bool) ApiGetBacklogRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiGetBacklogRequest) Execute() (PersistentOfflineTopicStats, *_nethttp.Response, error) {
	return r.ApiService.GetBacklogExecute(r)
}

/*
GetBacklog Get estimated backlog for offline topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiGetBacklogRequest
*/
func (a *PersistentTopicApiService) GetBacklog(ctx _context.Context, tenant string, namespace string, topic string) ApiGetBacklogRequest {
	return ApiGetBacklogRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return PersistentOfflineTopicStats
func (a *PersistentTopicApiService) GetBacklogExecute(r ApiGetBacklogRequest) (PersistentOfflineTopicStats, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersistentOfflineTopicStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetBacklog")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/backlog"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBacklogQuotaMapRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetBacklogQuotaMapRequest) Execute() (map[string]map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GetBacklogQuotaMapExecute(r)
}

/*
GetBacklogQuotaMap Get backlog quota map on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetBacklogQuotaMapRequest
*/
func (a *PersistentTopicApiService) GetBacklogQuotaMap(ctx _context.Context, tenant string, namespace string, topic string) ApiGetBacklogQuotaMapRequest {
	return ApiGetBacklogQuotaMapRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return map[string]map[string]interface{}
func (a *PersistentTopicApiService) GetBacklogQuotaMapExecute(r ApiGetBacklogQuotaMapRequest) (map[string]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetBacklogQuotaMap")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/backlogQuotaMap"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCompactionThresholdRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetCompactionThresholdRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetCompactionThresholdExecute(r)
}

/*
GetCompactionThreshold Get compaction threshold configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetCompactionThresholdRequest
*/
func (a *PersistentTopicApiService) GetCompactionThreshold(ctx _context.Context, tenant string, namespace string, topic string) ApiGetCompactionThresholdRequest {
	return ApiGetCompactionThresholdRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetCompactionThresholdExecute(r ApiGetCompactionThresholdRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetCompactionThreshold")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/compactionThreshold"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDeduplicationEnabledRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetDeduplicationEnabledRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetDeduplicationEnabledExecute(r)
}

/*
GetDeduplicationEnabled Get deduplication configuration of a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetDeduplicationEnabledRequest
*/
func (a *PersistentTopicApiService) GetDeduplicationEnabled(ctx _context.Context, tenant string, namespace string, topic string) ApiGetDeduplicationEnabledRequest {
	return ApiGetDeduplicationEnabledRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetDeduplicationEnabledExecute(r ApiGetDeduplicationEnabledRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetDeduplicationEnabled")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDeduplicationSnapshotIntervalRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetDeduplicationSnapshotIntervalRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetDeduplicationSnapshotIntervalExecute(r)
}

/*
GetDeduplicationSnapshotInterval Get deduplicationSnapshotInterval config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetDeduplicationSnapshotIntervalRequest
*/
func (a *PersistentTopicApiService) GetDeduplicationSnapshotInterval(ctx _context.Context, tenant string, namespace string, topic string) ApiGetDeduplicationSnapshotIntervalRequest {
	return ApiGetDeduplicationSnapshotIntervalRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetDeduplicationSnapshotIntervalExecute(r ApiGetDeduplicationSnapshotIntervalRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetDeduplicationSnapshotInterval")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDelayedDeliveryPoliciesRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetDelayedDeliveryPoliciesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetDelayedDeliveryPoliciesExecute(r)
}

/*
GetDelayedDeliveryPolicies Get delayed delivery messages config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetDelayedDeliveryPoliciesRequest
*/
func (a *PersistentTopicApiService) GetDelayedDeliveryPolicies(ctx _context.Context, tenant string, namespace string, topic string) ApiGetDelayedDeliveryPoliciesRequest {
	return ApiGetDelayedDeliveryPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetDelayedDeliveryPoliciesExecute(r ApiGetDelayedDeliveryPoliciesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetDelayedDeliveryPolicies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/delayedDelivery"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDispatchRateRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetDispatchRateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetDispatchRateExecute(r)
}

/*
GetDispatchRate Get dispatch rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetDispatchRateRequest
*/
func (a *PersistentTopicApiService) GetDispatchRate(ctx _context.Context, tenant string, namespace string, topic string) ApiGetDispatchRateRequest {
	return ApiGetDispatchRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetDispatchRateExecute(r ApiGetDispatchRateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetDispatchRate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/dispatchRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetInactiveTopicPoliciesRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetInactiveTopicPoliciesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetInactiveTopicPoliciesExecute(r)
}

/*
GetInactiveTopicPolicies Get inactive topic policies on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetInactiveTopicPoliciesRequest
*/
func (a *PersistentTopicApiService) GetInactiveTopicPolicies(ctx _context.Context, tenant string, namespace string, topic string) ApiGetInactiveTopicPoliciesRequest {
	return ApiGetInactiveTopicPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetInactiveTopicPoliciesExecute(r ApiGetInactiveTopicPoliciesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetInactiveTopicPolicies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetInternalStatsRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
	metadata *bool
}

// Is authentication required to perform this operation
func (r ApiGetInternalStatsRequest) Authoritative(authoritative bool) ApiGetInternalStatsRequest {
	r.authoritative = &authoritative
	return r
}
func (r ApiGetInternalStatsRequest) Metadata(metadata bool) ApiGetInternalStatsRequest {
	r.metadata = &metadata
	return r
}

func (r ApiGetInternalStatsRequest) Execute() (PersistentTopicInternalStats, *_nethttp.Response, error) {
	return r.ApiService.GetInternalStatsExecute(r)
}

/*
GetInternalStats Get the internal stats for the topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiGetInternalStatsRequest
*/
func (a *PersistentTopicApiService) GetInternalStats(ctx _context.Context, tenant string, namespace string, topic string) ApiGetInternalStatsRequest {
	return ApiGetInternalStatsRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return PersistentTopicInternalStats
func (a *PersistentTopicApiService) GetInternalStatsExecute(r ApiGetInternalStatsRequest) (PersistentTopicInternalStats, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersistentTopicInternalStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetInternalStats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/internalStats"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	if r.metadata != nil {
		localVarQueryParams.Add("metadata", parameterToString(*r.metadata, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLastMessageIdRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiGetLastMessageIdRequest) Authoritative(authoritative bool) ApiGetLastMessageIdRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiGetLastMessageIdRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetLastMessageIdExecute(r)
}

/*
GetLastMessageId Return the last commit message id of topic

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiGetLastMessageIdRequest
*/
func (a *PersistentTopicApiService) GetLastMessageId(ctx _context.Context, tenant string, namespace string, topic string) ApiGetLastMessageIdRequest {
	return ApiGetLastMessageIdRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetLastMessageIdExecute(r ApiGetLastMessageIdRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetLastMessageId")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/lastMessageId"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetListRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
}


func (r ApiGetListRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GetListExecute(r)
}

/*
GetList Get the list of topics under a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @return ApiGetListRequest
*/
func (a *PersistentTopicApiService) GetList(ctx _context.Context, tenant string, namespace string) ApiGetListRequest {
	return ApiGetListRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return []string
func (a *PersistentTopicApiService) GetListExecute(r ApiGetListRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagedLedgerInfoRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiGetManagedLedgerInfoRequest) Authoritative(authoritative bool) ApiGetManagedLedgerInfoRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiGetManagedLedgerInfoRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetManagedLedgerInfoExecute(r)
}

/*
GetManagedLedgerInfo Get the stored topic metadata.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiGetManagedLedgerInfoRequest
*/
func (a *PersistentTopicApiService) GetManagedLedgerInfo(ctx _context.Context, tenant string, namespace string, topic string) ApiGetManagedLedgerInfoRequest {
	return ApiGetManagedLedgerInfoRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetManagedLedgerInfoExecute(r ApiGetManagedLedgerInfoRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetManagedLedgerInfo")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/internal-info"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMaxConsumersRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetMaxConsumersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetMaxConsumersExecute(r)
}

/*
GetMaxConsumers Get maxConsumers config for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetMaxConsumersRequest
*/
func (a *PersistentTopicApiService) GetMaxConsumers(ctx _context.Context, tenant string, namespace string, topic string) ApiGetMaxConsumersRequest {
	return ApiGetMaxConsumersRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetMaxConsumersExecute(r ApiGetMaxConsumersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetMaxConsumers")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/maxConsumers"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMaxConsumersPerSubscriptionRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetMaxConsumersPerSubscriptionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetMaxConsumersPerSubscriptionExecute(r)
}

/*
GetMaxConsumersPerSubscription Get max consumers per subscription configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetMaxConsumersPerSubscriptionRequest
*/
func (a *PersistentTopicApiService) GetMaxConsumersPerSubscription(ctx _context.Context, tenant string, namespace string, topic string) ApiGetMaxConsumersPerSubscriptionRequest {
	return ApiGetMaxConsumersPerSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetMaxConsumersPerSubscriptionExecute(r ApiGetMaxConsumersPerSubscriptionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetMaxConsumersPerSubscription")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMaxProducersRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetMaxProducersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetMaxProducersExecute(r)
}

/*
GetMaxProducers Get maxProducers config for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetMaxProducersRequest
*/
func (a *PersistentTopicApiService) GetMaxProducers(ctx _context.Context, tenant string, namespace string, topic string) ApiGetMaxProducersRequest {
	return ApiGetMaxProducersRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetMaxProducersExecute(r ApiGetMaxProducersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetMaxProducers")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/maxProducers"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMaxUnackedMessagesOnConsumerRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetMaxUnackedMessagesOnConsumerRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetMaxUnackedMessagesOnConsumerExecute(r)
}

/*
GetMaxUnackedMessagesOnConsumer Get max unacked messages per consumer config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetMaxUnackedMessagesOnConsumerRequest
*/
func (a *PersistentTopicApiService) GetMaxUnackedMessagesOnConsumer(ctx _context.Context, tenant string, namespace string, topic string) ApiGetMaxUnackedMessagesOnConsumerRequest {
	return ApiGetMaxUnackedMessagesOnConsumerRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetMaxUnackedMessagesOnConsumerExecute(r ApiGetMaxUnackedMessagesOnConsumerRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetMaxUnackedMessagesOnConsumer")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMaxUnackedMessagesOnSubscriptionRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetMaxUnackedMessagesOnSubscriptionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetMaxUnackedMessagesOnSubscriptionExecute(r)
}

/*
GetMaxUnackedMessagesOnSubscription Get max unacked messages per subscription config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetMaxUnackedMessagesOnSubscriptionRequest
*/
func (a *PersistentTopicApiService) GetMaxUnackedMessagesOnSubscription(ctx _context.Context, tenant string, namespace string, topic string) ApiGetMaxUnackedMessagesOnSubscriptionRequest {
	return ApiGetMaxUnackedMessagesOnSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetMaxUnackedMessagesOnSubscriptionExecute(r ApiGetMaxUnackedMessagesOnSubscriptionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetMaxUnackedMessagesOnSubscription")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMessageByIdRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	ledgerId int64
	entryId int64
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiGetMessageByIdRequest) Authoritative(authoritative bool) ApiGetMessageByIdRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiGetMessageByIdRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetMessageByIdExecute(r)
}

/*
GetMessageById Get message by its messageId.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param ledgerId The ledger id
 @param entryId The entry id
 @return ApiGetMessageByIdRequest
*/
func (a *PersistentTopicApiService) GetMessageById(ctx _context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64) ApiGetMessageByIdRequest {
	return ApiGetMessageByIdRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		ledgerId: ledgerId,
		entryId: entryId,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetMessageByIdExecute(r ApiGetMessageByIdRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetMessageById")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/ledger/{ledgerId}/entry/{entryId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ledgerId"+"}", _neturl.PathEscape(parameterToString(r.ledgerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entryId"+"}", _neturl.PathEscape(parameterToString(r.entryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMessageTTLRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetMessageTTLRequest) Execute() (int32, *_nethttp.Response, error) {
	return r.ApiService.GetMessageTTLExecute(r)
}

/*
GetMessageTTL Get message TTL in seconds for a topic

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetMessageTTLRequest
*/
func (a *PersistentTopicApiService) GetMessageTTL(ctx _context.Context, tenant string, namespace string, topic string) ApiGetMessageTTLRequest {
	return ApiGetMessageTTLRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return int32
func (a *PersistentTopicApiService) GetMessageTTLExecute(r ApiGetMessageTTLRequest) (int32, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetMessageTTL")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/messageTTL"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOffloadPoliciesRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetOffloadPoliciesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetOffloadPoliciesExecute(r)
}

/*
GetOffloadPolicies Get offload policies on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetOffloadPoliciesRequest
*/
func (a *PersistentTopicApiService) GetOffloadPolicies(ctx _context.Context, tenant string, namespace string, topic string) ApiGetOffloadPoliciesRequest {
	return ApiGetOffloadPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetOffloadPoliciesExecute(r ApiGetOffloadPoliciesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetOffloadPolicies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/offloadPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPartitionedMetadataRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
	checkAllowAutoCreation *bool
}

// Is authentication required to perform this operation
func (r ApiGetPartitionedMetadataRequest) Authoritative(authoritative bool) ApiGetPartitionedMetadataRequest {
	r.authoritative = &authoritative
	return r
}
// Is check configuration required to automatically create topic
func (r ApiGetPartitionedMetadataRequest) CheckAllowAutoCreation(checkAllowAutoCreation bool) ApiGetPartitionedMetadataRequest {
	r.checkAllowAutoCreation = &checkAllowAutoCreation
	return r
}

func (r ApiGetPartitionedMetadataRequest) Execute() (PartitionedTopicMetadata, *_nethttp.Response, error) {
	return r.ApiService.GetPartitionedMetadataExecute(r)
}

/*
GetPartitionedMetadata Get partitioned topic metadata.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiGetPartitionedMetadataRequest
*/
func (a *PersistentTopicApiService) GetPartitionedMetadata(ctx _context.Context, tenant string, namespace string, topic string) ApiGetPartitionedMetadataRequest {
	return ApiGetPartitionedMetadataRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return PartitionedTopicMetadata
func (a *PersistentTopicApiService) GetPartitionedMetadataExecute(r ApiGetPartitionedMetadataRequest) (PartitionedTopicMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PartitionedTopicMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetPartitionedMetadata")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/partitions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	if r.checkAllowAutoCreation != nil {
		localVarQueryParams.Add("checkAllowAutoCreation", parameterToString(*r.checkAllowAutoCreation, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartitionedStatsRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	perPartition *bool
	authoritative *bool
	getPreciseBacklog *bool
}

// Get per partition stats
func (r ApiGetPartitionedStatsRequest) PerPartition(perPartition bool) ApiGetPartitionedStatsRequest {
	r.perPartition = &perPartition
	return r
}
// Is authentication required to perform this operation
func (r ApiGetPartitionedStatsRequest) Authoritative(authoritative bool) ApiGetPartitionedStatsRequest {
	r.authoritative = &authoritative
	return r
}
// Is return precise backlog or imprecise backlog
func (r ApiGetPartitionedStatsRequest) GetPreciseBacklog(getPreciseBacklog bool) ApiGetPartitionedStatsRequest {
	r.getPreciseBacklog = &getPreciseBacklog
	return r
}

func (r ApiGetPartitionedStatsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetPartitionedStatsExecute(r)
}

/*
GetPartitionedStats Get the stats for the partitioned topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiGetPartitionedStatsRequest
*/
func (a *PersistentTopicApiService) GetPartitionedStats(ctx _context.Context, tenant string, namespace string, topic string) ApiGetPartitionedStatsRequest {
	return ApiGetPartitionedStatsRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetPartitionedStatsExecute(r ApiGetPartitionedStatsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetPartitionedStats")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/partitioned-stats"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.perPartition != nil {
		localVarQueryParams.Add("perPartition", parameterToString(*r.perPartition, ""))
	}
	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	if r.getPreciseBacklog != nil {
		localVarQueryParams.Add("getPreciseBacklog", parameterToString(*r.getPreciseBacklog, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPartitionedTopicListRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
}


func (r ApiGetPartitionedTopicListRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GetPartitionedTopicListExecute(r)
}

/*
GetPartitionedTopicList Get the list of partitioned topics under a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @return ApiGetPartitionedTopicListRequest
*/
func (a *PersistentTopicApiService) GetPartitionedTopicList(ctx _context.Context, tenant string, namespace string) ApiGetPartitionedTopicListRequest {
	return ApiGetPartitionedTopicListRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return []string
func (a *PersistentTopicApiService) GetPartitionedTopicListExecute(r ApiGetPartitionedTopicListRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetPartitionedTopicList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/partitioned"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPermissionsOnTopicRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetPermissionsOnTopicRequest) Execute() (map[string]map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GetPermissionsOnTopicExecute(r)
}

/*
GetPermissionsOnTopic Get permissions on a topic.

Retrieve the effective permissions for a topic. These permissions are defined by the permissions set at thenamespace level combined (union) with any eventual specific permission set on the topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiGetPermissionsOnTopicRequest
*/
func (a *PersistentTopicApiService) GetPermissionsOnTopic(ctx _context.Context, tenant string, namespace string, topic string) ApiGetPermissionsOnTopicRequest {
	return ApiGetPermissionsOnTopicRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return map[string]map[string]interface{}
func (a *PersistentTopicApiService) GetPermissionsOnTopicExecute(r ApiGetPermissionsOnTopicRequest) (map[string]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetPermissionsOnTopic")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPersistenceRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetPersistenceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetPersistenceExecute(r)
}

/*
GetPersistence Get configuration of persistence policies for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetPersistenceRequest
*/
func (a *PersistentTopicApiService) GetPersistence(ctx _context.Context, tenant string, namespace string, topic string) ApiGetPersistenceRequest {
	return ApiGetPersistenceRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetPersistenceExecute(r ApiGetPersistenceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetPersistence")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/persistence"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPublishRateRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetPublishRateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetPublishRateExecute(r)
}

/*
GetPublishRate Get publish rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetPublishRateRequest
*/
func (a *PersistentTopicApiService) GetPublishRate(ctx _context.Context, tenant string, namespace string, topic string) ApiGetPublishRateRequest {
	return ApiGetPublishRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetPublishRateExecute(r ApiGetPublishRateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetPublishRate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/publishRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRetentionRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetRetentionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetRetentionExecute(r)
}

/*
GetRetention Get retention configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetRetentionRequest
*/
func (a *PersistentTopicApiService) GetRetention(ctx _context.Context, tenant string, namespace string, topic string) ApiGetRetentionRequest {
	return ApiGetRetentionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetRetentionExecute(r ApiGetRetentionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetRetention")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/retention"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetStatsRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
	getPreciseBacklog *bool
}

// Is authentication required to perform this operation
func (r ApiGetStatsRequest) Authoritative(authoritative bool) ApiGetStatsRequest {
	r.authoritative = &authoritative
	return r
}
// Is return precise backlog or imprecise backlog
func (r ApiGetStatsRequest) GetPreciseBacklog(getPreciseBacklog bool) ApiGetStatsRequest {
	r.getPreciseBacklog = &getPreciseBacklog
	return r
}

func (r ApiGetStatsRequest) Execute() (TopicStats, *_nethttp.Response, error) {
	return r.ApiService.GetStatsExecute(r)
}

/*
GetStats Get the stats for the topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiGetStatsRequest
*/
func (a *PersistentTopicApiService) GetStats(ctx _context.Context, tenant string, namespace string, topic string) ApiGetStatsRequest {
	return ApiGetStatsRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return TopicStats
func (a *PersistentTopicApiService) GetStatsExecute(r ApiGetStatsRequest) (TopicStats, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TopicStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetStats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	if r.getPreciseBacklog != nil {
		localVarQueryParams.Add("getPreciseBacklog", parameterToString(*r.getPreciseBacklog, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubscribeRateRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetSubscribeRateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetSubscribeRateExecute(r)
}

/*
GetSubscribeRate Get subscribe rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetSubscribeRateRequest
*/
func (a *PersistentTopicApiService) GetSubscribeRate(ctx _context.Context, tenant string, namespace string, topic string) ApiGetSubscribeRateRequest {
	return ApiGetSubscribeRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetSubscribeRateExecute(r ApiGetSubscribeRateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetSubscribeRate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/subscribeRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSubscriptionDispatchRateRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiGetSubscriptionDispatchRateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetSubscriptionDispatchRateExecute(r)
}

/*
GetSubscriptionDispatchRate Get subscription message dispatch rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiGetSubscriptionDispatchRateRequest
*/
func (a *PersistentTopicApiService) GetSubscriptionDispatchRate(ctx _context.Context, tenant string, namespace string, topic string) ApiGetSubscriptionDispatchRateRequest {
	return ApiGetSubscriptionDispatchRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetSubscriptionDispatchRateExecute(r ApiGetSubscriptionDispatchRateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetSubscriptionDispatchRate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiGetSubscriptionsRequest) Authoritative(authoritative bool) ApiGetSubscriptionsRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiGetSubscriptionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetSubscriptionsExecute(r)
}

/*
GetSubscriptions Get the list of persistent subscriptions for a given topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiGetSubscriptionsRequest
*/
func (a *PersistentTopicApiService) GetSubscriptions(ctx _context.Context, tenant string, namespace string, topic string) ApiGetSubscriptionsRequest {
	return ApiGetSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GetSubscriptionsExecute(r ApiGetSubscriptionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GetSubscriptions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/subscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGrantPermissionsOnTopicRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	role string
	body *[]string
}

// Actions to be granted (produce,functions,consume)
func (r ApiGrantPermissionsOnTopicRequest) Body(body []string) ApiGrantPermissionsOnTopicRequest {
	r.body = &body
	return r
}

func (r ApiGrantPermissionsOnTopicRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GrantPermissionsOnTopicExecute(r)
}

/*
GrantPermissionsOnTopic Grant a new permission to a role on a single topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param role Client role to which grant permissions
 @return ApiGrantPermissionsOnTopicRequest
*/
func (a *PersistentTopicApiService) GrantPermissionsOnTopic(ctx _context.Context, tenant string, namespace string, topic string, role string) ApiGrantPermissionsOnTopicRequest {
	return ApiGrantPermissionsOnTopicRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		role: role,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) GrantPermissionsOnTopicExecute(r ApiGrantPermissionsOnTopicRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.GrantPermissionsOnTopic")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/permissions/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", _neturl.PathEscape(parameterToString(r.role, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOffloadStatusRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiOffloadStatusRequest) Authoritative(authoritative bool) ApiOffloadStatusRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiOffloadStatusRequest) Execute() (OffloadProcessStatus, *_nethttp.Response, error) {
	return r.ApiService.OffloadStatusExecute(r)
}

/*
OffloadStatus Offload a prefix of a topic to long term storage

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiOffloadStatusRequest
*/
func (a *PersistentTopicApiService) OffloadStatus(ctx _context.Context, tenant string, namespace string, topic string) ApiOffloadStatusRequest {
	return ApiOffloadStatusRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return OffloadProcessStatus
func (a *PersistentTopicApiService) OffloadStatusExecute(r ApiOffloadStatusRequest) (OffloadProcessStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OffloadProcessStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.OffloadStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/offload"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPeekNthMessageRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	subName string
	messagePosition int32
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiPeekNthMessageRequest) Authoritative(authoritative bool) ApiPeekNthMessageRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiPeekNthMessageRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PeekNthMessageExecute(r)
}

/*
PeekNthMessage Peek nth message on a topic subscription.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param subName Subscribed message expired
 @param messagePosition The number of messages (default 1)
 @return ApiPeekNthMessageRequest
*/
func (a *PersistentTopicApiService) PeekNthMessage(ctx _context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32) ApiPeekNthMessageRequest {
	return ApiPeekNthMessageRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		subName: subName,
		messagePosition: messagePosition,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) PeekNthMessageExecute(r ApiPeekNthMessageRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.PeekNthMessage")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/position/{messagePosition}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.PathEscape(parameterToString(r.subName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"messagePosition"+"}", _neturl.PathEscape(parameterToString(r.messagePosition, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveBacklogQuotaRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	backlogQuotaType *string
}

func (r ApiRemoveBacklogQuotaRequest) BacklogQuotaType(backlogQuotaType string) ApiRemoveBacklogQuotaRequest {
	r.backlogQuotaType = &backlogQuotaType
	return r
}

func (r ApiRemoveBacklogQuotaRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveBacklogQuotaExecute(r)
}

/*
RemoveBacklogQuota Remove a backlog quota policy from a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveBacklogQuotaRequest
*/
func (a *PersistentTopicApiService) RemoveBacklogQuota(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveBacklogQuotaRequest {
	return ApiRemoveBacklogQuotaRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) RemoveBacklogQuotaExecute(r ApiRemoveBacklogQuotaRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.RemoveBacklogQuota")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/backlogQuota"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.backlogQuotaType != nil {
		localVarQueryParams.Add("backlogQuotaType", parameterToString(*r.backlogQuotaType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveCompactionThresholdRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveCompactionThresholdRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveCompactionThresholdExecute(r)
}

/*
RemoveCompactionThreshold Remove compaction threshold configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveCompactionThresholdRequest
*/
func (a *PersistentTopicApiService) RemoveCompactionThreshold(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveCompactionThresholdRequest {
	return ApiRemoveCompactionThresholdRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) RemoveCompactionThresholdExecute(r ApiRemoveCompactionThresholdRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.RemoveCompactionThreshold")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/compactionThreshold"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveDeduplicationEnabledRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveDeduplicationEnabledRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveDeduplicationEnabledExecute(r)
}

/*
RemoveDeduplicationEnabled Remove deduplication configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveDeduplicationEnabledRequest
*/
func (a *PersistentTopicApiService) RemoveDeduplicationEnabled(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveDeduplicationEnabledRequest {
	return ApiRemoveDeduplicationEnabledRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) RemoveDeduplicationEnabledExecute(r ApiRemoveDeduplicationEnabledRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.RemoveDeduplicationEnabled")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveDispatchRateRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveDispatchRateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveDispatchRateExecute(r)
}

/*
RemoveDispatchRate Remove message dispatch rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveDispatchRateRequest
*/
func (a *PersistentTopicApiService) RemoveDispatchRate(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveDispatchRateRequest {
	return ApiRemoveDispatchRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) RemoveDispatchRateExecute(r ApiRemoveDispatchRateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.RemoveDispatchRate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/dispatchRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveMaxConsumersRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveMaxConsumersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveMaxConsumersExecute(r)
}

/*
RemoveMaxConsumers Remove maxConsumers config for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveMaxConsumersRequest
*/
func (a *PersistentTopicApiService) RemoveMaxConsumers(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveMaxConsumersRequest {
	return ApiRemoveMaxConsumersRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) RemoveMaxConsumersExecute(r ApiRemoveMaxConsumersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.RemoveMaxConsumers")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/maxConsumers"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveMaxConsumersPerSubscriptionRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveMaxConsumersPerSubscriptionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveMaxConsumersPerSubscriptionExecute(r)
}

/*
RemoveMaxConsumersPerSubscription Remove max consumers per subscription configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveMaxConsumersPerSubscriptionRequest
*/
func (a *PersistentTopicApiService) RemoveMaxConsumersPerSubscription(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveMaxConsumersPerSubscriptionRequest {
	return ApiRemoveMaxConsumersPerSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) RemoveMaxConsumersPerSubscriptionExecute(r ApiRemoveMaxConsumersPerSubscriptionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.RemoveMaxConsumersPerSubscription")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveMaxProducersRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveMaxProducersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveMaxProducersExecute(r)
}

/*
RemoveMaxProducers Remove maxProducers config for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveMaxProducersRequest
*/
func (a *PersistentTopicApiService) RemoveMaxProducers(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveMaxProducersRequest {
	return ApiRemoveMaxProducersRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) RemoveMaxProducersExecute(r ApiRemoveMaxProducersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.RemoveMaxProducers")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/maxProducers"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveMessageTTLRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveMessageTTLRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveMessageTTLExecute(r)
}

/*
RemoveMessageTTL Remove message TTL in seconds for a topic

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveMessageTTLRequest
*/
func (a *PersistentTopicApiService) RemoveMessageTTL(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveMessageTTLRequest {
	return ApiRemoveMessageTTLRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) RemoveMessageTTLExecute(r ApiRemoveMessageTTLRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.RemoveMessageTTL")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/messageTTL"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveOffloadPoliciesRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveOffloadPoliciesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveOffloadPoliciesExecute(r)
}

/*
RemoveOffloadPolicies Delete offload policies on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveOffloadPoliciesRequest
*/
func (a *PersistentTopicApiService) RemoveOffloadPolicies(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveOffloadPoliciesRequest {
	return ApiRemoveOffloadPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) RemoveOffloadPoliciesExecute(r ApiRemoveOffloadPoliciesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.RemoveOffloadPolicies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/offloadPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemovePersistenceRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemovePersistenceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemovePersistenceExecute(r)
}

/*
RemovePersistence Remove configuration of persistence policies for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemovePersistenceRequest
*/
func (a *PersistentTopicApiService) RemovePersistence(ctx _context.Context, tenant string, namespace string, topic string) ApiRemovePersistenceRequest {
	return ApiRemovePersistenceRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) RemovePersistenceExecute(r ApiRemovePersistenceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.RemovePersistence")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/persistence"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemovePublishRateRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemovePublishRateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemovePublishRateExecute(r)
}

/*
RemovePublishRate Remove message publish rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemovePublishRateRequest
*/
func (a *PersistentTopicApiService) RemovePublishRate(ctx _context.Context, tenant string, namespace string, topic string) ApiRemovePublishRateRequest {
	return ApiRemovePublishRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) RemovePublishRateExecute(r ApiRemovePublishRateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.RemovePublishRate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/publishRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveRetentionRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveRetentionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveRetentionExecute(r)
}

/*
RemoveRetention Remove retention configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveRetentionRequest
*/
func (a *PersistentTopicApiService) RemoveRetention(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveRetentionRequest {
	return ApiRemoveRetentionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) RemoveRetentionExecute(r ApiRemoveRetentionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.RemoveRetention")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/retention"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveSubscribeRateRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveSubscribeRateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveSubscribeRateExecute(r)
}

/*
RemoveSubscribeRate Remove subscribe rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveSubscribeRateRequest
*/
func (a *PersistentTopicApiService) RemoveSubscribeRate(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveSubscribeRateRequest {
	return ApiRemoveSubscribeRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) RemoveSubscribeRateExecute(r ApiRemoveSubscribeRateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.RemoveSubscribeRate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/subscribeRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveSubscriptionDispatchRateRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
}


func (r ApiRemoveSubscriptionDispatchRateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveSubscriptionDispatchRateExecute(r)
}

/*
RemoveSubscriptionDispatchRate Remove subscription message dispatch rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiRemoveSubscriptionDispatchRateRequest
*/
func (a *PersistentTopicApiService) RemoveSubscriptionDispatchRate(ctx _context.Context, tenant string, namespace string, topic string) ApiRemoveSubscriptionDispatchRateRequest {
	return ApiRemoveSubscriptionDispatchRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) RemoveSubscriptionDispatchRateExecute(r ApiRemoveSubscriptionDispatchRateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.RemoveSubscriptionDispatchRate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiResetCursorRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	subName string
	timestamp int64
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiResetCursorRequest) Authoritative(authoritative bool) ApiResetCursorRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiResetCursorRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ResetCursorExecute(r)
}

/*
ResetCursor Reset subscription to message position closest to absolute timestamp (in ms).

It fence cursor and disconnects all active consumers before reseting cursor.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param subName Subscription to reset position on
 @param timestamp time in minutes to reset back to (or minutes, hours,days,weeks eg:100m, 3h, 2d, 5w)
 @return ApiResetCursorRequest
*/
func (a *PersistentTopicApiService) ResetCursor(ctx _context.Context, tenant string, namespace string, topic string, subName string, timestamp int64) ApiResetCursorRequest {
	return ApiResetCursorRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		subName: subName,
		timestamp: timestamp,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) ResetCursorExecute(r ApiResetCursorRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.ResetCursor")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor/{timestamp}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.PathEscape(parameterToString(r.subName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timestamp"+"}", _neturl.PathEscape(parameterToString(r.timestamp, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiResetCursorOnPositionRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	subName string
	authoritative *bool
	messageId *ResetCursorData
}

// Is authentication required to perform this operation
func (r ApiResetCursorOnPositionRequest) Authoritative(authoritative bool) ApiResetCursorOnPositionRequest {
	r.authoritative = &authoritative
	return r
}
// messageId to reset back to (ledgerId:entryId)
func (r ApiResetCursorOnPositionRequest) MessageId(messageId ResetCursorData) ApiResetCursorOnPositionRequest {
	r.messageId = &messageId
	return r
}

func (r ApiResetCursorOnPositionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ResetCursorOnPositionExecute(r)
}

/*
ResetCursorOnPosition Reset subscription to message position closest to given position.

It fence cursor and disconnects all active consumers before reseting cursor.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param subName Subscription to reset position on
 @return ApiResetCursorOnPositionRequest
*/
func (a *PersistentTopicApiService) ResetCursorOnPosition(ctx _context.Context, tenant string, namespace string, topic string, subName string) ApiResetCursorOnPositionRequest {
	return ApiResetCursorOnPositionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		subName: subName,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) ResetCursorOnPositionExecute(r ApiResetCursorOnPositionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.ResetCursorOnPosition")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.PathEscape(parameterToString(r.subName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.messageId
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRevokePermissionsOnTopicRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	role string
}


func (r ApiRevokePermissionsOnTopicRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RevokePermissionsOnTopicExecute(r)
}

/*
RevokePermissionsOnTopic Revoke permissions on a topic.

Revoke permissions to a role on a single topic. If the permission was not set at the topiclevel, but rather at the namespace level, this operation will return an error (HTTP status code 412).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param role Client role to which grant permissions
 @return ApiRevokePermissionsOnTopicRequest
*/
func (a *PersistentTopicApiService) RevokePermissionsOnTopic(ctx _context.Context, tenant string, namespace string, topic string, role string) ApiRevokePermissionsOnTopicRequest {
	return ApiRevokePermissionsOnTopicRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		role: role,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) RevokePermissionsOnTopicExecute(r ApiRevokePermissionsOnTopicRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.RevokePermissionsOnTopic")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/permissions/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", _neturl.PathEscape(parameterToString(r.role, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetBacklogQuotaRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	backlogQuotaType *string
}

func (r ApiSetBacklogQuotaRequest) BacklogQuotaType(backlogQuotaType string) ApiSetBacklogQuotaRequest {
	r.backlogQuotaType = &backlogQuotaType
	return r
}

func (r ApiSetBacklogQuotaRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetBacklogQuotaExecute(r)
}

/*
SetBacklogQuota Set a backlog quota for a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetBacklogQuotaRequest
*/
func (a *PersistentTopicApiService) SetBacklogQuota(ctx _context.Context, tenant string, namespace string, topic string) ApiSetBacklogQuotaRequest {
	return ApiSetBacklogQuotaRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetBacklogQuotaExecute(r ApiSetBacklogQuotaRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetBacklogQuota")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/backlogQuota"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.backlogQuotaType != nil {
		localVarQueryParams.Add("backlogQuotaType", parameterToString(*r.backlogQuotaType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetCompactionThresholdRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *int64
}

// Dispatch rate for the specified topic
func (r ApiSetCompactionThresholdRequest) Body(body int64) ApiSetCompactionThresholdRequest {
	r.body = &body
	return r
}

func (r ApiSetCompactionThresholdRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetCompactionThresholdExecute(r)
}

/*
SetCompactionThreshold Set compaction threshold configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetCompactionThresholdRequest
*/
func (a *PersistentTopicApiService) SetCompactionThreshold(ctx _context.Context, tenant string, namespace string, topic string) ApiSetCompactionThresholdRequest {
	return ApiSetCompactionThresholdRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetCompactionThresholdExecute(r ApiSetCompactionThresholdRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetCompactionThreshold")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/compactionThreshold"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetDeduplicationEnabledRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *bool
}

// DeduplicationEnabled policies for the specified topic
func (r ApiSetDeduplicationEnabledRequest) Body(body bool) ApiSetDeduplicationEnabledRequest {
	r.body = &body
	return r
}

func (r ApiSetDeduplicationEnabledRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetDeduplicationEnabledExecute(r)
}

/*
SetDeduplicationEnabled Set deduplication enabled on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetDeduplicationEnabledRequest
*/
func (a *PersistentTopicApiService) SetDeduplicationEnabled(ctx _context.Context, tenant string, namespace string, topic string) ApiSetDeduplicationEnabledRequest {
	return ApiSetDeduplicationEnabledRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetDeduplicationEnabledExecute(r ApiSetDeduplicationEnabledRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetDeduplicationEnabled")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetDeduplicationSnapshotIntervalRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *int32
}

// Interval to take deduplication snapshot for the specified topic
func (r ApiSetDeduplicationSnapshotIntervalRequest) Body(body int32) ApiSetDeduplicationSnapshotIntervalRequest {
	r.body = &body
	return r
}

func (r ApiSetDeduplicationSnapshotIntervalRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetDeduplicationSnapshotIntervalExecute(r)
}

/*
SetDeduplicationSnapshotInterval Set deduplicationSnapshotInterval config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetDeduplicationSnapshotIntervalRequest
*/
func (a *PersistentTopicApiService) SetDeduplicationSnapshotInterval(ctx _context.Context, tenant string, namespace string, topic string) ApiSetDeduplicationSnapshotIntervalRequest {
	return ApiSetDeduplicationSnapshotIntervalRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetDeduplicationSnapshotIntervalExecute(r ApiSetDeduplicationSnapshotIntervalRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetDeduplicationSnapshotInterval")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetDelayedDeliveryPoliciesRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *DelayedDeliveryPolicies
}

// Delayed delivery policies for the specified topic
func (r ApiSetDelayedDeliveryPoliciesRequest) Body(body DelayedDeliveryPolicies) ApiSetDelayedDeliveryPoliciesRequest {
	r.body = &body
	return r
}

func (r ApiSetDelayedDeliveryPoliciesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetDelayedDeliveryPoliciesExecute(r)
}

/*
SetDelayedDeliveryPolicies Set delayed delivery messages config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetDelayedDeliveryPoliciesRequest
*/
func (a *PersistentTopicApiService) SetDelayedDeliveryPolicies(ctx _context.Context, tenant string, namespace string, topic string) ApiSetDelayedDeliveryPoliciesRequest {
	return ApiSetDelayedDeliveryPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetDelayedDeliveryPoliciesExecute(r ApiSetDelayedDeliveryPoliciesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetDelayedDeliveryPolicies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/delayedDelivery"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetDispatchRateRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *DispatchRate
}

// Dispatch rate for the specified topic
func (r ApiSetDispatchRateRequest) Body(body DispatchRate) ApiSetDispatchRateRequest {
	r.body = &body
	return r
}

func (r ApiSetDispatchRateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetDispatchRateExecute(r)
}

/*
SetDispatchRate Set message dispatch rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetDispatchRateRequest
*/
func (a *PersistentTopicApiService) SetDispatchRate(ctx _context.Context, tenant string, namespace string, topic string) ApiSetDispatchRateRequest {
	return ApiSetDispatchRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetDispatchRateExecute(r ApiSetDispatchRateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetDispatchRate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/dispatchRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetInactiveTopicPoliciesRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *InactiveTopicPolicies
}

// inactive topic policies for the specified topic
func (r ApiSetInactiveTopicPoliciesRequest) Body(body InactiveTopicPolicies) ApiSetInactiveTopicPoliciesRequest {
	r.body = &body
	return r
}

func (r ApiSetInactiveTopicPoliciesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetInactiveTopicPoliciesExecute(r)
}

/*
SetInactiveTopicPolicies Set inactive topic policies on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetInactiveTopicPoliciesRequest
*/
func (a *PersistentTopicApiService) SetInactiveTopicPolicies(ctx _context.Context, tenant string, namespace string, topic string) ApiSetInactiveTopicPoliciesRequest {
	return ApiSetInactiveTopicPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetInactiveTopicPoliciesExecute(r ApiSetInactiveTopicPoliciesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetInactiveTopicPolicies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetMaxConsumersRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *int32
}

// The max consumers of the topic
func (r ApiSetMaxConsumersRequest) Body(body int32) ApiSetMaxConsumersRequest {
	r.body = &body
	return r
}

func (r ApiSetMaxConsumersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetMaxConsumersExecute(r)
}

/*
SetMaxConsumers Set maxConsumers config for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetMaxConsumersRequest
*/
func (a *PersistentTopicApiService) SetMaxConsumers(ctx _context.Context, tenant string, namespace string, topic string) ApiSetMaxConsumersRequest {
	return ApiSetMaxConsumersRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetMaxConsumersExecute(r ApiSetMaxConsumersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetMaxConsumers")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/maxConsumers"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetMaxConsumersPerSubscriptionRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *int32
}

// Dispatch rate for the specified topic
func (r ApiSetMaxConsumersPerSubscriptionRequest) Body(body int32) ApiSetMaxConsumersPerSubscriptionRequest {
	r.body = &body
	return r
}

func (r ApiSetMaxConsumersPerSubscriptionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetMaxConsumersPerSubscriptionExecute(r)
}

/*
SetMaxConsumersPerSubscription Set max consumers per subscription configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetMaxConsumersPerSubscriptionRequest
*/
func (a *PersistentTopicApiService) SetMaxConsumersPerSubscription(ctx _context.Context, tenant string, namespace string, topic string) ApiSetMaxConsumersPerSubscriptionRequest {
	return ApiSetMaxConsumersPerSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetMaxConsumersPerSubscriptionExecute(r ApiSetMaxConsumersPerSubscriptionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetMaxConsumersPerSubscription")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetMaxProducersRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *int32
}

// The max producers of the topic
func (r ApiSetMaxProducersRequest) Body(body int32) ApiSetMaxProducersRequest {
	r.body = &body
	return r
}

func (r ApiSetMaxProducersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetMaxProducersExecute(r)
}

/*
SetMaxProducers Set maxProducers config for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetMaxProducersRequest
*/
func (a *PersistentTopicApiService) SetMaxProducers(ctx _context.Context, tenant string, namespace string, topic string) ApiSetMaxProducersRequest {
	return ApiSetMaxProducersRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetMaxProducersExecute(r ApiSetMaxProducersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetMaxProducers")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/maxProducers"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetMaxUnackedMessagesOnConsumerRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *int32
}

// Max unacked messages on consumer policies for the specified topic
func (r ApiSetMaxUnackedMessagesOnConsumerRequest) Body(body int32) ApiSetMaxUnackedMessagesOnConsumerRequest {
	r.body = &body
	return r
}

func (r ApiSetMaxUnackedMessagesOnConsumerRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetMaxUnackedMessagesOnConsumerExecute(r)
}

/*
SetMaxUnackedMessagesOnConsumer Set max unacked messages per consumer config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetMaxUnackedMessagesOnConsumerRequest
*/
func (a *PersistentTopicApiService) SetMaxUnackedMessagesOnConsumer(ctx _context.Context, tenant string, namespace string, topic string) ApiSetMaxUnackedMessagesOnConsumerRequest {
	return ApiSetMaxUnackedMessagesOnConsumerRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetMaxUnackedMessagesOnConsumerExecute(r ApiSetMaxUnackedMessagesOnConsumerRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetMaxUnackedMessagesOnConsumer")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetMaxUnackedMessagesOnSubscriptionRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *int32
}

// Max unacked messages on subscription policies for the specified topic
func (r ApiSetMaxUnackedMessagesOnSubscriptionRequest) Body(body int32) ApiSetMaxUnackedMessagesOnSubscriptionRequest {
	r.body = &body
	return r
}

func (r ApiSetMaxUnackedMessagesOnSubscriptionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetMaxUnackedMessagesOnSubscriptionExecute(r)
}

/*
SetMaxUnackedMessagesOnSubscription Set max unacked messages per subscription config on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetMaxUnackedMessagesOnSubscriptionRequest
*/
func (a *PersistentTopicApiService) SetMaxUnackedMessagesOnSubscription(ctx _context.Context, tenant string, namespace string, topic string) ApiSetMaxUnackedMessagesOnSubscriptionRequest {
	return ApiSetMaxUnackedMessagesOnSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetMaxUnackedMessagesOnSubscriptionExecute(r ApiSetMaxUnackedMessagesOnSubscriptionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetMaxUnackedMessagesOnSubscription")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetMessageTTLRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	messageTTL *int32
}

// TTL in seconds for the specified namespace
func (r ApiSetMessageTTLRequest) MessageTTL(messageTTL int32) ApiSetMessageTTLRequest {
	r.messageTTL = &messageTTL
	return r
}

func (r ApiSetMessageTTLRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetMessageTTLExecute(r)
}

/*
SetMessageTTL Set message TTL in seconds for a topic

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetMessageTTLRequest
*/
func (a *PersistentTopicApiService) SetMessageTTL(ctx _context.Context, tenant string, namespace string, topic string) ApiSetMessageTTLRequest {
	return ApiSetMessageTTLRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetMessageTTLExecute(r ApiSetMessageTTLRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetMessageTTL")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/messageTTL"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.messageTTL == nil {
		return nil, reportError("messageTTL is required and must be specified")
	}

	localVarQueryParams.Add("messageTTL", parameterToString(*r.messageTTL, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetOffloadPoliciesRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *OffloadPolicies
}

// Offload policies for the specified topic
func (r ApiSetOffloadPoliciesRequest) Body(body OffloadPolicies) ApiSetOffloadPoliciesRequest {
	r.body = &body
	return r
}

func (r ApiSetOffloadPoliciesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetOffloadPoliciesExecute(r)
}

/*
SetOffloadPolicies Set offload policies on a topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetOffloadPoliciesRequest
*/
func (a *PersistentTopicApiService) SetOffloadPolicies(ctx _context.Context, tenant string, namespace string, topic string) ApiSetOffloadPoliciesRequest {
	return ApiSetOffloadPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetOffloadPoliciesExecute(r ApiSetOffloadPoliciesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetOffloadPolicies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/offloadPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetPersistenceRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *PersistencePolicies
}

// Bookkeeper persistence policies for specified topic
func (r ApiSetPersistenceRequest) Body(body PersistencePolicies) ApiSetPersistenceRequest {
	r.body = &body
	return r
}

func (r ApiSetPersistenceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetPersistenceExecute(r)
}

/*
SetPersistence Set configuration of persistence policies for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetPersistenceRequest
*/
func (a *PersistentTopicApiService) SetPersistence(ctx _context.Context, tenant string, namespace string, topic string) ApiSetPersistenceRequest {
	return ApiSetPersistenceRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetPersistenceExecute(r ApiSetPersistenceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetPersistence")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/persistence"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetPublishRateRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *PublishRate
}

// Dispatch rate for the specified topic
func (r ApiSetPublishRateRequest) Body(body PublishRate) ApiSetPublishRateRequest {
	r.body = &body
	return r
}

func (r ApiSetPublishRateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetPublishRateExecute(r)
}

/*
SetPublishRate Set message publish rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetPublishRateRequest
*/
func (a *PersistentTopicApiService) SetPublishRate(ctx _context.Context, tenant string, namespace string, topic string) ApiSetPublishRateRequest {
	return ApiSetPublishRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetPublishRateExecute(r ApiSetPublishRateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetPublishRate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/publishRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetRetentionRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *RetentionPolicies
}

// Retention policies for the specified namespace
func (r ApiSetRetentionRequest) Body(body RetentionPolicies) ApiSetRetentionRequest {
	r.body = &body
	return r
}

func (r ApiSetRetentionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetRetentionExecute(r)
}

/*
SetRetention Set retention configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetRetentionRequest
*/
func (a *PersistentTopicApiService) SetRetention(ctx _context.Context, tenant string, namespace string, topic string) ApiSetRetentionRequest {
	return ApiSetRetentionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetRetentionExecute(r ApiSetRetentionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetRetention")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/retention"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetSubscribeRateRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *SubscribeRate
}

// Subscribe rate for the specified topic
func (r ApiSetSubscribeRateRequest) Body(body SubscribeRate) ApiSetSubscribeRateRequest {
	r.body = &body
	return r
}

func (r ApiSetSubscribeRateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetSubscribeRateExecute(r)
}

/*
SetSubscribeRate Set subscribe rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetSubscribeRateRequest
*/
func (a *PersistentTopicApiService) SetSubscribeRate(ctx _context.Context, tenant string, namespace string, topic string) ApiSetSubscribeRateRequest {
	return ApiSetSubscribeRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetSubscribeRateExecute(r ApiSetSubscribeRateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetSubscribeRate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/subscribeRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetSubscriptionDispatchRateRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *DispatchRate
}

// Subscription message dispatch rate for the specified topic
func (r ApiSetSubscriptionDispatchRateRequest) Body(body DispatchRate) ApiSetSubscriptionDispatchRateRequest {
	r.body = &body
	return r
}

func (r ApiSetSubscriptionDispatchRateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetSubscriptionDispatchRateExecute(r)
}

/*
SetSubscriptionDispatchRate Set subscription message dispatch rate configuration for specified topic.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param topic
 @return ApiSetSubscriptionDispatchRateRequest
*/
func (a *PersistentTopicApiService) SetSubscriptionDispatchRate(ctx _context.Context, tenant string, namespace string, topic string) ApiSetSubscriptionDispatchRateRequest {
	return ApiSetSubscriptionDispatchRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SetSubscriptionDispatchRateExecute(r ApiSetSubscriptionDispatchRateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SetSubscriptionDispatchRate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSkipAllMessagesRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	subName string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiSkipAllMessagesRequest) Authoritative(authoritative bool) ApiSkipAllMessagesRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiSkipAllMessagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SkipAllMessagesExecute(r)
}

/*
SkipAllMessages Skip all messages on a topic subscription.

Completely clears the backlog on the subscription.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param subName Name of subscription
 @return ApiSkipAllMessagesRequest
*/
func (a *PersistentTopicApiService) SkipAllMessages(ctx _context.Context, tenant string, namespace string, topic string, subName string) ApiSkipAllMessagesRequest {
	return ApiSkipAllMessagesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		subName: subName,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SkipAllMessagesExecute(r ApiSkipAllMessagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SkipAllMessages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip_all"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.PathEscape(parameterToString(r.subName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSkipMessagesRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	subName string
	numMessages int32
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiSkipMessagesRequest) Authoritative(authoritative bool) ApiSkipMessagesRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiSkipMessagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SkipMessagesExecute(r)
}

/*
SkipMessages Skipping messages on a topic subscription.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @param subName Name of subscription
 @param numMessages The number of messages to skip
 @return ApiSkipMessagesRequest
*/
func (a *PersistentTopicApiService) SkipMessages(ctx _context.Context, tenant string, namespace string, topic string, subName string, numMessages int32) ApiSkipMessagesRequest {
	return ApiSkipMessagesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
		subName: subName,
		numMessages: numMessages,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) SkipMessagesExecute(r ApiSkipMessagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.SkipMessages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip/{numMessages}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.PathEscape(parameterToString(r.subName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"numMessages"+"}", _neturl.PathEscape(parameterToString(r.numMessages, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTerminateRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiTerminateRequest) Authoritative(authoritative bool) ApiTerminateRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiTerminateRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.TerminateExecute(r)
}

/*
Terminate Terminate a persistent topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiTerminateRequest
*/
func (a *PersistentTopicApiService) Terminate(ctx _context.Context, tenant string, namespace string, topic string) ApiTerminateRequest {
	return ApiTerminateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PersistentTopicApiService) TerminateExecute(r ApiTerminateRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.Terminate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/terminate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTerminatePartitionedTopicRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiTerminatePartitionedTopicRequest) Authoritative(authoritative bool) ApiTerminatePartitionedTopicRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiTerminatePartitionedTopicRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TerminatePartitionedTopicExecute(r)
}

/*
TerminatePartitionedTopic Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiTerminatePartitionedTopicRequest
*/
func (a *PersistentTopicApiService) TerminatePartitionedTopic(ctx _context.Context, tenant string, namespace string, topic string) ApiTerminatePartitionedTopicRequest {
	return ApiTerminatePartitionedTopicRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) TerminatePartitionedTopicExecute(r ApiTerminatePartitionedTopicRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.TerminatePartitionedTopic")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/terminate/partitions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTriggerOffloadRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiTriggerOffloadRequest) Authoritative(authoritative bool) ApiTriggerOffloadRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiTriggerOffloadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TriggerOffloadExecute(r)
}

/*
TriggerOffload Offload a prefix of a topic to long term storage

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiTriggerOffloadRequest
*/
func (a *PersistentTopicApiService) TriggerOffload(ctx _context.Context, tenant string, namespace string, topic string) ApiTriggerOffloadRequest {
	return ApiTriggerOffloadRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) TriggerOffloadExecute(r ApiTriggerOffloadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.TriggerOffload")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/offload"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnloadTopicRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	authoritative *bool
}

// Is authentication required to perform this operation
func (r ApiUnloadTopicRequest) Authoritative(authoritative bool) ApiUnloadTopicRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiUnloadTopicRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UnloadTopicExecute(r)
}

/*
UnloadTopic Unload a topic

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiUnloadTopicRequest
*/
func (a *PersistentTopicApiService) UnloadTopic(ctx _context.Context, tenant string, namespace string, topic string) ApiUnloadTopicRequest {
	return ApiUnloadTopicRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) UnloadTopicExecute(r ApiUnloadTopicRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.UnloadTopic")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/unload"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdatePartitionedTopicRequest struct {
	ctx _context.Context
	ApiService *PersistentTopicApiService
	tenant string
	namespace string
	topic string
	body *int32
	updateLocalTopicOnly *bool
	authoritative *bool
}

// The number of partitions for the topic
func (r ApiUpdatePartitionedTopicRequest) Body(body int32) ApiUpdatePartitionedTopicRequest {
	r.body = &body
	return r
}
func (r ApiUpdatePartitionedTopicRequest) UpdateLocalTopicOnly(updateLocalTopicOnly bool) ApiUpdatePartitionedTopicRequest {
	r.updateLocalTopicOnly = &updateLocalTopicOnly
	return r
}
// Is authentication required to perform this operation
func (r ApiUpdatePartitionedTopicRequest) Authoritative(authoritative bool) ApiUpdatePartitionedTopicRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiUpdatePartitionedTopicRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdatePartitionedTopicExecute(r)
}

/*
UpdatePartitionedTopic Increment partitions of an existing partitioned topic.

It only increments partitions of existing non-global partitioned-topic

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant Specify the tenant
 @param namespace Specify the namespace
 @param topic Specify topic name
 @return ApiUpdatePartitionedTopicRequest
*/
func (a *PersistentTopicApiService) UpdatePartitionedTopic(ctx _context.Context, tenant string, namespace string, topic string) ApiUpdatePartitionedTopicRequest {
	return ApiUpdatePartitionedTopicRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		topic: topic,
	}
}

// Execute executes the request
func (a *PersistentTopicApiService) UpdatePartitionedTopicExecute(r ApiUpdatePartitionedTopicRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersistentTopicApiService.UpdatePartitionedTopic")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persistent/{tenant}/{namespace}/{topic}/partitions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.PathEscape(parameterToString(r.topic, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.updateLocalTopicOnly != nil {
		localVarQueryParams.Add("updateLocalTopicOnly", parameterToString(*r.updateLocalTopicOnly, ""))
	}
	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
