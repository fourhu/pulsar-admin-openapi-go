/*
Pulsar Admin REST API

This provides the REST API for admin operations

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// NamespacesApiService NamespacesApi service
type NamespacesApiService service

type ApiClearNamespaceBacklogRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	authoritative *bool
}

func (r ApiClearNamespaceBacklogRequest) Authoritative(authoritative bool) ApiClearNamespaceBacklogRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiClearNamespaceBacklogRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ClearNamespaceBacklogExecute(r)
}

/*
ClearNamespaceBacklog Clear backlog for all topics on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiClearNamespaceBacklogRequest
*/
func (a *NamespacesApiService) ClearNamespaceBacklog(ctx _context.Context, tenant string, namespace string) ApiClearNamespaceBacklogRequest {
	return ApiClearNamespaceBacklogRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) ClearNamespaceBacklogExecute(r ApiClearNamespaceBacklogRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.ClearNamespaceBacklog")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/clearBacklog"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClearNamespaceBacklogForSubscriptionRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	subscription string
	authoritative *bool
}

func (r ApiClearNamespaceBacklogForSubscriptionRequest) Authoritative(authoritative bool) ApiClearNamespaceBacklogForSubscriptionRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiClearNamespaceBacklogForSubscriptionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ClearNamespaceBacklogForSubscriptionExecute(r)
}

/*
ClearNamespaceBacklogForSubscription Clear backlog for a given subscription on all topics on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param subscription
 @return ApiClearNamespaceBacklogForSubscriptionRequest
*/
func (a *NamespacesApiService) ClearNamespaceBacklogForSubscription(ctx _context.Context, tenant string, namespace string, subscription string) ApiClearNamespaceBacklogForSubscriptionRequest {
	return ApiClearNamespaceBacklogForSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		subscription: subscription,
	}
}

// Execute executes the request
func (a *NamespacesApiService) ClearNamespaceBacklogForSubscriptionExecute(r ApiClearNamespaceBacklogForSubscriptionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.ClearNamespaceBacklogForSubscription")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/clearBacklog/{subscription}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscription"+"}", _neturl.PathEscape(parameterToString(r.subscription, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClearNamespaceBundleBacklogRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	bundle string
	authoritative *bool
}

func (r ApiClearNamespaceBundleBacklogRequest) Authoritative(authoritative bool) ApiClearNamespaceBundleBacklogRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiClearNamespaceBundleBacklogRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ClearNamespaceBundleBacklogExecute(r)
}

/*
ClearNamespaceBundleBacklog Clear backlog for all topics on a namespace bundle.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param bundle
 @return ApiClearNamespaceBundleBacklogRequest
*/
func (a *NamespacesApiService) ClearNamespaceBundleBacklog(ctx _context.Context, tenant string, namespace string, bundle string) ApiClearNamespaceBundleBacklogRequest {
	return ApiClearNamespaceBundleBacklogRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		bundle: bundle,
	}
}

// Execute executes the request
func (a *NamespacesApiService) ClearNamespaceBundleBacklogExecute(r ApiClearNamespaceBundleBacklogRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.ClearNamespaceBundleBacklog")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/{bundle}/clearBacklog"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bundle"+"}", _neturl.PathEscape(parameterToString(r.bundle, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClearNamespaceBundleBacklogForSubscriptionRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	subscription string
	bundle string
	authoritative *bool
}

func (r ApiClearNamespaceBundleBacklogForSubscriptionRequest) Authoritative(authoritative bool) ApiClearNamespaceBundleBacklogForSubscriptionRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiClearNamespaceBundleBacklogForSubscriptionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ClearNamespaceBundleBacklogForSubscriptionExecute(r)
}

/*
ClearNamespaceBundleBacklogForSubscription Clear backlog for a given subscription on all topics on a namespace bundle.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param subscription
 @param bundle
 @return ApiClearNamespaceBundleBacklogForSubscriptionRequest
*/
func (a *NamespacesApiService) ClearNamespaceBundleBacklogForSubscription(ctx _context.Context, tenant string, namespace string, subscription string, bundle string) ApiClearNamespaceBundleBacklogForSubscriptionRequest {
	return ApiClearNamespaceBundleBacklogForSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		subscription: subscription,
		bundle: bundle,
	}
}

// Execute executes the request
func (a *NamespacesApiService) ClearNamespaceBundleBacklogForSubscriptionExecute(r ApiClearNamespaceBundleBacklogForSubscriptionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.ClearNamespaceBundleBacklogForSubscription")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/{bundle}/clearBacklog/{subscription}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscription"+"}", _neturl.PathEscape(parameterToString(r.subscription, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bundle"+"}", _neturl.PathEscape(parameterToString(r.bundle, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClearOffloadDeletionLagRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiClearOffloadDeletionLagRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ClearOffloadDeletionLagExecute(r)
}

/*
ClearOffloadDeletionLag Clear the namespace configured offload deletion lag. The topics in the namespace will fallback to using the default configured deletion lag for the broker

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiClearOffloadDeletionLagRequest
*/
func (a *NamespacesApiService) ClearOffloadDeletionLag(ctx _context.Context, tenant string, namespace string) ApiClearOffloadDeletionLagRequest {
	return ApiClearOffloadDeletionLagRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) ClearOffloadDeletionLagExecute(r ApiClearOffloadDeletionLagRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.ClearOffloadDeletionLag")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/offloadDeletionLagMs"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateNamespaceRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *Policies
}

// Policies for the namespace
func (r ApiCreateNamespaceRequest) Body(body Policies) ApiCreateNamespaceRequest {
	r.body = &body
	return r
}

func (r ApiCreateNamespaceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateNamespaceExecute(r)
}

/*
CreateNamespace Creates a new namespace with the specified policies

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiCreateNamespaceRequest
*/
func (a *NamespacesApiService) CreateNamespace(ctx _context.Context, tenant string, namespace string) ApiCreateNamespaceRequest {
	return ApiCreateNamespaceRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) CreateNamespaceExecute(r ApiCreateNamespaceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.CreateNamespace")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteBookieAffinityGroupRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	property string
	namespace string
}


func (r ApiDeleteBookieAffinityGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteBookieAffinityGroupExecute(r)
}

/*
DeleteBookieAffinityGroup Delete the bookie-affinity-group from namespace-local policy.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param property
 @param namespace
 @return ApiDeleteBookieAffinityGroupRequest
*/
func (a *NamespacesApiService) DeleteBookieAffinityGroup(ctx _context.Context, property string, namespace string) ApiDeleteBookieAffinityGroupRequest {
	return ApiDeleteBookieAffinityGroupRequest{
		ApiService: a,
		ctx: ctx,
		property: property,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) DeleteBookieAffinityGroupExecute(r ApiDeleteBookieAffinityGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.DeleteBookieAffinityGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{property}/{namespace}/persistence/bookieAffinity"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", _neturl.PathEscape(parameterToString(r.property, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteNamespaceRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	force *bool
	authoritative *bool
}

func (r ApiDeleteNamespaceRequest) Force(force bool) ApiDeleteNamespaceRequest {
	r.force = &force
	return r
}
func (r ApiDeleteNamespaceRequest) Authoritative(authoritative bool) ApiDeleteNamespaceRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiDeleteNamespaceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteNamespaceExecute(r)
}

/*
DeleteNamespace Delete a namespace and all the topics under it.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiDeleteNamespaceRequest
*/
func (a *NamespacesApiService) DeleteNamespace(ctx _context.Context, tenant string, namespace string) ApiDeleteNamespaceRequest {
	return ApiDeleteNamespaceRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) DeleteNamespaceExecute(r ApiDeleteNamespaceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.DeleteNamespace")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteNamespaceBundleRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	bundle string
	force *bool
	authoritative *bool
}

func (r ApiDeleteNamespaceBundleRequest) Force(force bool) ApiDeleteNamespaceBundleRequest {
	r.force = &force
	return r
}
func (r ApiDeleteNamespaceBundleRequest) Authoritative(authoritative bool) ApiDeleteNamespaceBundleRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiDeleteNamespaceBundleRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteNamespaceBundleExecute(r)
}

/*
DeleteNamespaceBundle Delete a namespace bundle and all the topics under it.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param bundle
 @return ApiDeleteNamespaceBundleRequest
*/
func (a *NamespacesApiService) DeleteNamespaceBundle(ctx _context.Context, tenant string, namespace string, bundle string) ApiDeleteNamespaceBundleRequest {
	return ApiDeleteNamespaceBundleRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		bundle: bundle,
	}
}

// Execute executes the request
func (a *NamespacesApiService) DeleteNamespaceBundleExecute(r ApiDeleteNamespaceBundleRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.DeleteNamespaceBundle")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/{bundle}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bundle"+"}", _neturl.PathEscape(parameterToString(r.bundle, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAntiAffinityNamespacesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	cluster string
	group string
	tenant *string
}

func (r ApiGetAntiAffinityNamespacesRequest) Tenant(tenant string) ApiGetAntiAffinityNamespacesRequest {
	r.tenant = &tenant
	return r
}

func (r ApiGetAntiAffinityNamespacesRequest) Execute() ([]map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GetAntiAffinityNamespacesExecute(r)
}

/*
GetAntiAffinityNamespaces Get all namespaces that are grouped by given anti-affinity group in a given cluster. api can be only accessed by admin of any of the existing tenant

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cluster
 @param group
 @return ApiGetAntiAffinityNamespacesRequest
*/
func (a *NamespacesApiService) GetAntiAffinityNamespaces(ctx _context.Context, cluster string, group string) ApiGetAntiAffinityNamespacesRequest {
	return ApiGetAntiAffinityNamespacesRequest{
		ApiService: a,
		ctx: ctx,
		cluster: cluster,
		group: group,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *NamespacesApiService) GetAntiAffinityNamespacesExecute(r ApiGetAntiAffinityNamespacesRequest) ([]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetAntiAffinityNamespaces")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{cluster}/antiAffinity/{group}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster"+"}", _neturl.PathEscape(parameterToString(r.cluster, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group"+"}", _neturl.PathEscape(parameterToString(r.group, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.tenant != nil {
		localVarQueryParams.Add("tenant", parameterToString(*r.tenant, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBookieAffinityGroupRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	property string
	namespace string
}


func (r ApiGetBookieAffinityGroupRequest) Execute() (BookieAffinityGroupData, *_nethttp.Response, error) {
	return r.ApiService.GetBookieAffinityGroupExecute(r)
}

/*
GetBookieAffinityGroup Get the bookie-affinity-group from namespace-local policy.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param property
 @param namespace
 @return ApiGetBookieAffinityGroupRequest
*/
func (a *NamespacesApiService) GetBookieAffinityGroup(ctx _context.Context, property string, namespace string) ApiGetBookieAffinityGroupRequest {
	return ApiGetBookieAffinityGroupRequest{
		ApiService: a,
		ctx: ctx,
		property: property,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return BookieAffinityGroupData
func (a *NamespacesApiService) GetBookieAffinityGroupExecute(r ApiGetBookieAffinityGroupRequest) (BookieAffinityGroupData, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BookieAffinityGroupData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetBookieAffinityGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{property}/{namespace}/persistence/bookieAffinity"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", _neturl.PathEscape(parameterToString(r.property, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBundlesDataRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetBundlesDataRequest) Execute() (BundlesData, *_nethttp.Response, error) {
	return r.ApiService.GetBundlesDataExecute(r)
}

/*
GetBundlesData Get the bundles split data.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetBundlesDataRequest
*/
func (a *NamespacesApiService) GetBundlesData(ctx _context.Context, tenant string, namespace string) ApiGetBundlesDataRequest {
	return ApiGetBundlesDataRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return BundlesData
func (a *NamespacesApiService) GetBundlesDataExecute(r ApiGetBundlesDataRequest) (BundlesData, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BundlesData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetBundlesData")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/bundles"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIsAllowAutoUpdateSchemaRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetIsAllowAutoUpdateSchemaRequest) Execute() (bool, *_nethttp.Response, error) {
	return r.ApiService.GetIsAllowAutoUpdateSchemaExecute(r)
}

/*
GetIsAllowAutoUpdateSchema The flag of whether allow auto update schema

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetIsAllowAutoUpdateSchemaRequest
*/
func (a *NamespacesApiService) GetIsAllowAutoUpdateSchema(ctx _context.Context, tenant string, namespace string) ApiGetIsAllowAutoUpdateSchemaRequest {
	return ApiGetIsAllowAutoUpdateSchemaRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return bool
func (a *NamespacesApiService) GetIsAllowAutoUpdateSchemaExecute(r ApiGetIsAllowAutoUpdateSchemaRequest) (bool, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetIsAllowAutoUpdateSchema")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/isAllowAutoUpdateSchema"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMaxConsumersPerTopicRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetMaxConsumersPerTopicRequest) Execute() (int32, *_nethttp.Response, error) {
	return r.ApiService.GetMaxConsumersPerTopicExecute(r)
}

/*
GetMaxConsumersPerTopic Get maxConsumersPerTopic config on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetMaxConsumersPerTopicRequest
*/
func (a *NamespacesApiService) GetMaxConsumersPerTopic(ctx _context.Context, tenant string, namespace string) ApiGetMaxConsumersPerTopicRequest {
	return ApiGetMaxConsumersPerTopicRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return int32
func (a *NamespacesApiService) GetMaxConsumersPerTopicExecute(r ApiGetMaxConsumersPerTopicRequest) (int32, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetMaxConsumersPerTopic")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/maxConsumersPerTopic"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMaxProducersPerTopicRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetMaxProducersPerTopicRequest) Execute() (int32, *_nethttp.Response, error) {
	return r.ApiService.GetMaxProducersPerTopicExecute(r)
}

/*
GetMaxProducersPerTopic Get maxProducersPerTopic config on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetMaxProducersPerTopicRequest
*/
func (a *NamespacesApiService) GetMaxProducersPerTopic(ctx _context.Context, tenant string, namespace string) ApiGetMaxProducersPerTopicRequest {
	return ApiGetMaxProducersPerTopicRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return int32
func (a *NamespacesApiService) GetMaxProducersPerTopicExecute(r ApiGetMaxProducersPerTopicRequest) (int32, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetMaxProducersPerTopic")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/maxProducersPerTopic"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMaxUnackedMessagesPerConsumerRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetMaxUnackedMessagesPerConsumerRequest) Execute() (int32, *_nethttp.Response, error) {
	return r.ApiService.GetMaxUnackedMessagesPerConsumerExecute(r)
}

/*
GetMaxUnackedMessagesPerConsumer Get maxUnackedMessagesPerConsumer config on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetMaxUnackedMessagesPerConsumerRequest
*/
func (a *NamespacesApiService) GetMaxUnackedMessagesPerConsumer(ctx _context.Context, tenant string, namespace string) ApiGetMaxUnackedMessagesPerConsumerRequest {
	return ApiGetMaxUnackedMessagesPerConsumerRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return int32
func (a *NamespacesApiService) GetMaxUnackedMessagesPerConsumerExecute(r ApiGetMaxUnackedMessagesPerConsumerRequest) (int32, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetMaxUnackedMessagesPerConsumer")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/maxUnackedMessagesPerConsumer"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMaxUnackedmessagesPerSubscriptionRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetMaxUnackedmessagesPerSubscriptionRequest) Execute() (int32, *_nethttp.Response, error) {
	return r.ApiService.GetMaxUnackedmessagesPerSubscriptionExecute(r)
}

/*
GetMaxUnackedmessagesPerSubscription Get maxUnackedMessagesPerSubscription config on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetMaxUnackedmessagesPerSubscriptionRequest
*/
func (a *NamespacesApiService) GetMaxUnackedmessagesPerSubscription(ctx _context.Context, tenant string, namespace string) ApiGetMaxUnackedmessagesPerSubscriptionRequest {
	return ApiGetMaxUnackedmessagesPerSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return int32
func (a *NamespacesApiService) GetMaxUnackedmessagesPerSubscriptionExecute(r ApiGetMaxUnackedmessagesPerSubscriptionRequest) (int32, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetMaxUnackedmessagesPerSubscription")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/maxUnackedMessagesPerSubscription"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNameSpaceBacklogQuotaMapRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetNameSpaceBacklogQuotaMapRequest) Execute() (map[string]map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GetNameSpaceBacklogQuotaMapExecute(r)
}

/*
GetNameSpaceBacklogQuotaMap Get backlog quota map on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetNameSpaceBacklogQuotaMapRequest
*/
func (a *NamespacesApiService) GetNameSpaceBacklogQuotaMap(ctx _context.Context, tenant string, namespace string) ApiGetNameSpaceBacklogQuotaMapRequest {
	return ApiGetNameSpaceBacklogQuotaMapRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return map[string]map[string]interface{}
func (a *NamespacesApiService) GetNameSpaceBacklogQuotaMapExecute(r ApiGetNameSpaceBacklogQuotaMapRequest) (map[string]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetNameSpaceBacklogQuotaMap")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/backlogQuotaMap"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNameSpaceCompactionThresholdRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetNameSpaceCompactionThresholdRequest) Execute() (int64, *_nethttp.Response, error) {
	return r.ApiService.GetNameSpaceCompactionThresholdExecute(r)
}

/*
GetNameSpaceCompactionThreshold Maximum number of uncompacted bytes in topics before compaction is triggered.

The backlog size is compared to the threshold periodically. A threshold of 0 disabled automatic compaction

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetNameSpaceCompactionThresholdRequest
*/
func (a *NamespacesApiService) GetNameSpaceCompactionThreshold(ctx _context.Context, tenant string, namespace string) ApiGetNameSpaceCompactionThresholdRequest {
	return ApiGetNameSpaceCompactionThresholdRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return int64
func (a *NamespacesApiService) GetNameSpaceCompactionThresholdExecute(r ApiGetNameSpaceCompactionThresholdRequest) (int64, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetNameSpaceCompactionThreshold")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/compactionThreshold"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNameSpaceDeduplicationSnapshotIntervalRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetNameSpaceDeduplicationSnapshotIntervalRequest) Execute() (int32, *_nethttp.Response, error) {
	return r.ApiService.GetNameSpaceDeduplicationSnapshotIntervalExecute(r)
}

/*
GetNameSpaceDeduplicationSnapshotInterval Get deduplicationSnapshotInterval config on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetNameSpaceDeduplicationSnapshotIntervalRequest
*/
func (a *NamespacesApiService) GetNameSpaceDeduplicationSnapshotInterval(ctx _context.Context, tenant string, namespace string) ApiGetNameSpaceDeduplicationSnapshotIntervalRequest {
	return ApiGetNameSpaceDeduplicationSnapshotIntervalRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return int32
func (a *NamespacesApiService) GetNameSpaceDeduplicationSnapshotIntervalExecute(r ApiGetNameSpaceDeduplicationSnapshotIntervalRequest) (int32, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetNameSpaceDeduplicationSnapshotInterval")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/deduplicationSnapshotInterval"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNameSpaceDelayedDeliveryPoliciesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetNameSpaceDelayedDeliveryPoliciesRequest) Execute() (DelayedDeliveryPolicies, *_nethttp.Response, error) {
	return r.ApiService.GetNameSpaceDelayedDeliveryPoliciesExecute(r)
}

/*
GetNameSpaceDelayedDeliveryPolicies Get delayed delivery messages config on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetNameSpaceDelayedDeliveryPoliciesRequest
*/
func (a *NamespacesApiService) GetNameSpaceDelayedDeliveryPolicies(ctx _context.Context, tenant string, namespace string) ApiGetNameSpaceDelayedDeliveryPoliciesRequest {
	return ApiGetNameSpaceDelayedDeliveryPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return DelayedDeliveryPolicies
func (a *NamespacesApiService) GetNameSpaceDelayedDeliveryPoliciesExecute(r ApiGetNameSpaceDelayedDeliveryPoliciesRequest) (DelayedDeliveryPolicies, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DelayedDeliveryPolicies
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetNameSpaceDelayedDeliveryPolicies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/delayedDelivery"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNameSpaceDispatchRateRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetNameSpaceDispatchRateRequest) Execute() (DispatchRate, *_nethttp.Response, error) {
	return r.ApiService.GetNameSpaceDispatchRateExecute(r)
}

/*
GetNameSpaceDispatchRate Get dispatch-rate configured for the namespace, -1 represents not configured yet

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetNameSpaceDispatchRateRequest
*/
func (a *NamespacesApiService) GetNameSpaceDispatchRate(ctx _context.Context, tenant string, namespace string) ApiGetNameSpaceDispatchRateRequest {
	return ApiGetNameSpaceDispatchRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return DispatchRate
func (a *NamespacesApiService) GetNameSpaceDispatchRateExecute(r ApiGetNameSpaceDispatchRateRequest) (DispatchRate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DispatchRate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetNameSpaceDispatchRate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/dispatchRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNameSpaceInactiveTopicPoliciesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetNameSpaceInactiveTopicPoliciesRequest) Execute() (InactiveTopicPolicies, *_nethttp.Response, error) {
	return r.ApiService.GetNameSpaceInactiveTopicPoliciesExecute(r)
}

/*
GetNameSpaceInactiveTopicPolicies Get inactive topic policies config on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetNameSpaceInactiveTopicPoliciesRequest
*/
func (a *NamespacesApiService) GetNameSpaceInactiveTopicPolicies(ctx _context.Context, tenant string, namespace string) ApiGetNameSpaceInactiveTopicPoliciesRequest {
	return ApiGetNameSpaceInactiveTopicPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return InactiveTopicPolicies
func (a *NamespacesApiService) GetNameSpaceInactiveTopicPoliciesExecute(r ApiGetNameSpaceInactiveTopicPoliciesRequest) (InactiveTopicPolicies, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InactiveTopicPolicies
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetNameSpaceInactiveTopicPolicies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/inactiveTopicPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNameSpaceMaxConsumersPerSubscriptionRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetNameSpaceMaxConsumersPerSubscriptionRequest) Execute() (int32, *_nethttp.Response, error) {
	return r.ApiService.GetNameSpaceMaxConsumersPerSubscriptionExecute(r)
}

/*
GetNameSpaceMaxConsumersPerSubscription Get maxConsumersPerSubscription config on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetNameSpaceMaxConsumersPerSubscriptionRequest
*/
func (a *NamespacesApiService) GetNameSpaceMaxConsumersPerSubscription(ctx _context.Context, tenant string, namespace string) ApiGetNameSpaceMaxConsumersPerSubscriptionRequest {
	return ApiGetNameSpaceMaxConsumersPerSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return int32
func (a *NamespacesApiService) GetNameSpaceMaxConsumersPerSubscriptionExecute(r ApiGetNameSpaceMaxConsumersPerSubscriptionRequest) (int32, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetNameSpaceMaxConsumersPerSubscription")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/maxConsumersPerSubscription"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNameSpaceOffloadPoliciesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetNameSpaceOffloadPoliciesRequest) Execute() (OffloadPolicies, *_nethttp.Response, error) {
	return r.ApiService.GetNameSpaceOffloadPoliciesExecute(r)
}

/*
GetNameSpaceOffloadPolicies Get offload configuration on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetNameSpaceOffloadPoliciesRequest
*/
func (a *NamespacesApiService) GetNameSpaceOffloadPolicies(ctx _context.Context, tenant string, namespace string) ApiGetNameSpaceOffloadPoliciesRequest {
	return ApiGetNameSpaceOffloadPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return OffloadPolicies
func (a *NamespacesApiService) GetNameSpaceOffloadPoliciesExecute(r ApiGetNameSpaceOffloadPoliciesRequest) (OffloadPolicies, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OffloadPolicies
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetNameSpaceOffloadPolicies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/offloadPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNameSpacePersistenceRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetNameSpacePersistenceRequest) Execute() (PersistencePolicies, *_nethttp.Response, error) {
	return r.ApiService.GetNameSpacePersistenceExecute(r)
}

/*
GetNameSpacePersistence Get the persistence configuration for a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetNameSpacePersistenceRequest
*/
func (a *NamespacesApiService) GetNameSpacePersistence(ctx _context.Context, tenant string, namespace string) ApiGetNameSpacePersistenceRequest {
	return ApiGetNameSpacePersistenceRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return PersistencePolicies
func (a *NamespacesApiService) GetNameSpacePersistenceExecute(r ApiGetNameSpacePersistenceRequest) (PersistencePolicies, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersistencePolicies
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetNameSpacePersistence")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/persistence"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNameSpaceRetentionRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetNameSpaceRetentionRequest) Execute() (RetentionPolicies, *_nethttp.Response, error) {
	return r.ApiService.GetNameSpaceRetentionExecute(r)
}

/*
GetNameSpaceRetention Get retention config on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetNameSpaceRetentionRequest
*/
func (a *NamespacesApiService) GetNameSpaceRetention(ctx _context.Context, tenant string, namespace string) ApiGetNameSpaceRetentionRequest {
	return ApiGetNameSpaceRetentionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return RetentionPolicies
func (a *NamespacesApiService) GetNameSpaceRetentionExecute(r ApiGetNameSpaceRetentionRequest) (RetentionPolicies, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RetentionPolicies
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetNameSpaceRetention")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/retention"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNameSpaceSubscribeRateRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetNameSpaceSubscribeRateRequest) Execute() (SubscribeRate, *_nethttp.Response, error) {
	return r.ApiService.GetNameSpaceSubscribeRateExecute(r)
}

/*
GetNameSpaceSubscribeRate Get subscribe-rate configured for the namespace

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetNameSpaceSubscribeRateRequest
*/
func (a *NamespacesApiService) GetNameSpaceSubscribeRate(ctx _context.Context, tenant string, namespace string) ApiGetNameSpaceSubscribeRateRequest {
	return ApiGetNameSpaceSubscribeRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return SubscribeRate
func (a *NamespacesApiService) GetNameSpaceSubscribeRateExecute(r ApiGetNameSpaceSubscribeRateRequest) (SubscribeRate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SubscribeRate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetNameSpaceSubscribeRate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/subscribeRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNameSpaceSubscriptionDispatchRateRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetNameSpaceSubscriptionDispatchRateRequest) Execute() (DispatchRate, *_nethttp.Response, error) {
	return r.ApiService.GetNameSpaceSubscriptionDispatchRateExecute(r)
}

/*
GetNameSpaceSubscriptionDispatchRate Get Subscription dispatch-rate configured for the namespace, -1 represents not configured yet

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetNameSpaceSubscriptionDispatchRateRequest
*/
func (a *NamespacesApiService) GetNameSpaceSubscriptionDispatchRate(ctx _context.Context, tenant string, namespace string) ApiGetNameSpaceSubscriptionDispatchRateRequest {
	return ApiGetNameSpaceSubscriptionDispatchRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return DispatchRate
func (a *NamespacesApiService) GetNameSpaceSubscriptionDispatchRateExecute(r ApiGetNameSpaceSubscriptionDispatchRateRequest) (DispatchRate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DispatchRate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetNameSpaceSubscriptionDispatchRate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/subscriptionDispatchRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNamespaceAntiAffinityGroupRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetNamespaceAntiAffinityGroupRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GetNamespaceAntiAffinityGroupExecute(r)
}

/*
GetNamespaceAntiAffinityGroup Get anti-affinity group of a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetNamespaceAntiAffinityGroupRequest
*/
func (a *NamespacesApiService) GetNamespaceAntiAffinityGroup(ctx _context.Context, tenant string, namespace string) ApiGetNamespaceAntiAffinityGroupRequest {
	return ApiGetNamespaceAntiAffinityGroupRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return string
func (a *NamespacesApiService) GetNamespaceAntiAffinityGroupExecute(r ApiGetNamespaceAntiAffinityGroupRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetNamespaceAntiAffinityGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/antiAffinity"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNamespaceMessageTTLRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetNamespaceMessageTTLRequest) Execute() (int32, *_nethttp.Response, error) {
	return r.ApiService.GetNamespaceMessageTTLExecute(r)
}

/*
GetNamespaceMessageTTL Get the message TTL for the namespace

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetNamespaceMessageTTLRequest
*/
func (a *NamespacesApiService) GetNamespaceMessageTTL(ctx _context.Context, tenant string, namespace string) ApiGetNamespaceMessageTTLRequest {
	return ApiGetNamespaceMessageTTLRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return int32
func (a *NamespacesApiService) GetNamespaceMessageTTLExecute(r ApiGetNamespaceMessageTTLRequest) (int32, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetNamespaceMessageTTL")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/messageTTL"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNamespaceReplicationClustersRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetNamespaceReplicationClustersRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GetNamespaceReplicationClustersExecute(r)
}

/*
GetNamespaceReplicationClusters Get the replication clusters for a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetNamespaceReplicationClustersRequest
*/
func (a *NamespacesApiService) GetNamespaceReplicationClusters(ctx _context.Context, tenant string, namespace string) ApiGetNamespaceReplicationClustersRequest {
	return ApiGetNamespaceReplicationClustersRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return []string
func (a *NamespacesApiService) GetNamespaceReplicationClustersExecute(r ApiGetNamespaceReplicationClustersRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetNamespaceReplicationClusters")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/replication"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOffloadDeletionLagRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetOffloadDeletionLagRequest) Execute() (int64, *_nethttp.Response, error) {
	return r.ApiService.GetOffloadDeletionLagExecute(r)
}

/*
GetOffloadDeletionLag Number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)

A negative value denotes that deletion has been completely disabled. 'null' denotes that the topics in the namespace will fall back to the broker default for deletion lag.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetOffloadDeletionLagRequest
*/
func (a *NamespacesApiService) GetOffloadDeletionLag(ctx _context.Context, tenant string, namespace string) ApiGetOffloadDeletionLagRequest {
	return ApiGetOffloadDeletionLagRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return int64
func (a *NamespacesApiService) GetOffloadDeletionLagExecute(r ApiGetOffloadDeletionLagRequest) (int64, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetOffloadDeletionLag")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/offloadDeletionLagMs"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOffloadThresholdRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetOffloadThresholdRequest) Execute() (int64, *_nethttp.Response, error) {
	return r.ApiService.GetOffloadThresholdExecute(r)
}

/*
GetOffloadThreshold Maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage

A negative value disables automatic offloading

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetOffloadThresholdRequest
*/
func (a *NamespacesApiService) GetOffloadThreshold(ctx _context.Context, tenant string, namespace string) ApiGetOffloadThresholdRequest {
	return ApiGetOffloadThresholdRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return int64
func (a *NamespacesApiService) GetOffloadThresholdExecute(r ApiGetOffloadThresholdRequest) (int64, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetOffloadThreshold")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/offloadThreshold"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPermissionsRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetPermissionsRequest) Execute() (map[string]map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GetPermissionsExecute(r)
}

/*
GetPermissions Retrieve the permissions for a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetPermissionsRequest
*/
func (a *NamespacesApiService) GetPermissions(ctx _context.Context, tenant string, namespace string) ApiGetPermissionsRequest {
	return ApiGetPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return map[string]map[string]interface{}
func (a *NamespacesApiService) GetPermissionsExecute(r ApiGetPermissionsRequest) (map[string]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetPermissions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPoliciesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetPoliciesRequest) Execute() (Policies, *_nethttp.Response, error) {
	return r.ApiService.GetPoliciesExecute(r)
}

/*
GetPolicies Get the dump all the policies specified for a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetPoliciesRequest
*/
func (a *NamespacesApiService) GetPolicies(ctx _context.Context, tenant string, namespace string) ApiGetPoliciesRequest {
	return ApiGetPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return Policies
func (a *NamespacesApiService) GetPoliciesExecute(r ApiGetPoliciesRequest) (Policies, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Policies
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetPolicies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReplicatorDispatchRateRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetReplicatorDispatchRateRequest) Execute() (DispatchRate, *_nethttp.Response, error) {
	return r.ApiService.GetReplicatorDispatchRateExecute(r)
}

/*
GetReplicatorDispatchRate Get replicator dispatch-rate configured for the namespace, -1 represents not configured yet

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetReplicatorDispatchRateRequest
*/
func (a *NamespacesApiService) GetReplicatorDispatchRate(ctx _context.Context, tenant string, namespace string) ApiGetReplicatorDispatchRateRequest {
	return ApiGetReplicatorDispatchRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return DispatchRate
func (a *NamespacesApiService) GetReplicatorDispatchRateExecute(r ApiGetReplicatorDispatchRateRequest) (DispatchRate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DispatchRate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetReplicatorDispatchRate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/replicatorDispatchRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSchemaAutoUpdateCompatibilityStrategyRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetSchemaAutoUpdateCompatibilityStrategyRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GetSchemaAutoUpdateCompatibilityStrategyExecute(r)
}

/*
GetSchemaAutoUpdateCompatibilityStrategy The strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema

The value AutoUpdateDisabled prevents producers from updating the schema.  If set to AutoUpdateDisabled, schemas must be updated through the REST api

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetSchemaAutoUpdateCompatibilityStrategyRequest
*/
func (a *NamespacesApiService) GetSchemaAutoUpdateCompatibilityStrategy(ctx _context.Context, tenant string, namespace string) ApiGetSchemaAutoUpdateCompatibilityStrategyRequest {
	return ApiGetSchemaAutoUpdateCompatibilityStrategyRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return string
func (a *NamespacesApiService) GetSchemaAutoUpdateCompatibilityStrategyExecute(r ApiGetSchemaAutoUpdateCompatibilityStrategyRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetSchemaAutoUpdateCompatibilityStrategy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/schemaAutoUpdateCompatibilityStrategy"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSchemaCompatibilityStrategyRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetSchemaCompatibilityStrategyRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GetSchemaCompatibilityStrategyExecute(r)
}

/*
GetSchemaCompatibilityStrategy The strategy of the namespace schema compatibility 

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetSchemaCompatibilityStrategyRequest
*/
func (a *NamespacesApiService) GetSchemaCompatibilityStrategy(ctx _context.Context, tenant string, namespace string) ApiGetSchemaCompatibilityStrategyRequest {
	return ApiGetSchemaCompatibilityStrategyRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return string
func (a *NamespacesApiService) GetSchemaCompatibilityStrategyExecute(r ApiGetSchemaCompatibilityStrategyRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetSchemaCompatibilityStrategy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/schemaCompatibilityStrategy"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSchemaValidtionEnforcedRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetSchemaValidtionEnforcedRequest) Execute() (bool, *_nethttp.Response, error) {
	return r.ApiService.GetSchemaValidtionEnforcedExecute(r)
}

/*
GetSchemaValidtionEnforced Get schema validation enforced flag for namespace.

If the flag is set to true, when a producer without a schema attempts to produce to a topic with schema in this namespace, the producer will be failed to connect. PLEASE be carefully on using this, since non-java clients don't support schema.if you enable this setting, it will cause non-java clients failed to produce.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetSchemaValidtionEnforcedRequest
*/
func (a *NamespacesApiService) GetSchemaValidtionEnforced(ctx _context.Context, tenant string, namespace string) ApiGetSchemaValidtionEnforcedRequest {
	return ApiGetSchemaValidtionEnforcedRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return bool
func (a *NamespacesApiService) GetSchemaValidtionEnforcedExecute(r ApiGetSchemaValidtionEnforcedRequest) (bool, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetSchemaValidtionEnforced")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/schemaValidationEnforced"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubscriptionExpirationTimeRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiGetSubscriptionExpirationTimeRequest) Execute() (int32, *_nethttp.Response, error) {
	return r.ApiService.GetSubscriptionExpirationTimeExecute(r)
}

/*
GetSubscriptionExpirationTime Get the subscription expiration time for the namespace

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetSubscriptionExpirationTimeRequest
*/
func (a *NamespacesApiService) GetSubscriptionExpirationTime(ctx _context.Context, tenant string, namespace string) ApiGetSubscriptionExpirationTimeRequest {
	return ApiGetSubscriptionExpirationTimeRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return int32
func (a *NamespacesApiService) GetSubscriptionExpirationTimeExecute(r ApiGetSubscriptionExpirationTimeRequest) (int32, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetSubscriptionExpirationTime")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/subscriptionExpirationTime"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTenantNamespacesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
}


func (r ApiGetTenantNamespacesRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GetTenantNamespacesExecute(r)
}

/*
GetTenantNamespaces Get the list of all the namespaces for a certain tenant.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @return ApiGetTenantNamespacesRequest
*/
func (a *NamespacesApiService) GetTenantNamespaces(ctx _context.Context, tenant string) ApiGetTenantNamespacesRequest {
	return ApiGetTenantNamespacesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
	}
}

// Execute executes the request
//  @return []string
func (a *NamespacesApiService) GetTenantNamespacesExecute(r ApiGetTenantNamespacesRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetTenantNamespaces")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTopicsRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	mode *string
}

func (r ApiGetTopicsRequest) Mode(mode string) ApiGetTopicsRequest {
	r.mode = &mode
	return r
}

func (r ApiGetTopicsRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GetTopicsExecute(r)
}

/*
GetTopics Get the list of all the topics under a certain namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiGetTopicsRequest
*/
func (a *NamespacesApiService) GetTopics(ctx _context.Context, tenant string, namespace string) ApiGetTopicsRequest {
	return ApiGetTopicsRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return []string
func (a *NamespacesApiService) GetTopicsExecute(r ApiGetTopicsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetTopics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/topics"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.mode != nil {
		localVarQueryParams.Add("mode", parameterToString(*r.mode, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGrantPermissionOnNamespaceRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	role string
	body *[]string
}

// List of permissions for the specified role
func (r ApiGrantPermissionOnNamespaceRequest) Body(body []string) ApiGrantPermissionOnNamespaceRequest {
	r.body = &body
	return r
}

func (r ApiGrantPermissionOnNamespaceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GrantPermissionOnNamespaceExecute(r)
}

/*
GrantPermissionOnNamespace Grant a new permission to a role on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param role
 @return ApiGrantPermissionOnNamespaceRequest
*/
func (a *NamespacesApiService) GrantPermissionOnNamespace(ctx _context.Context, tenant string, namespace string, role string) ApiGrantPermissionOnNamespaceRequest {
	return ApiGrantPermissionOnNamespaceRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		role: role,
	}
}

// Execute executes the request
func (a *NamespacesApiService) GrantPermissionOnNamespaceExecute(r ApiGrantPermissionOnNamespaceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GrantPermissionOnNamespace")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/permissions/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", _neturl.PathEscape(parameterToString(r.role, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiModifyDeduplicationRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *bool
}

// Flag for disabling or enabling broker side deduplication for all topics in the specified namespace
func (r ApiModifyDeduplicationRequest) Body(body bool) ApiModifyDeduplicationRequest {
	r.body = &body
	return r
}

func (r ApiModifyDeduplicationRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ModifyDeduplicationExecute(r)
}

/*
ModifyDeduplication Enable or disable broker side deduplication for all topics in a namespace

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiModifyDeduplicationRequest
*/
func (a *NamespacesApiService) ModifyDeduplication(ctx _context.Context, tenant string, namespace string) ApiModifyDeduplicationRequest {
	return ApiModifyDeduplicationRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) ModifyDeduplicationExecute(r ApiModifyDeduplicationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.ModifyDeduplication")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/deduplication"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiModifyEncryptionRequiredRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *bool
}

// Flag defining if message encryption is required
func (r ApiModifyEncryptionRequiredRequest) Body(body bool) ApiModifyEncryptionRequiredRequest {
	r.body = &body
	return r
}

func (r ApiModifyEncryptionRequiredRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ModifyEncryptionRequiredExecute(r)
}

/*
ModifyEncryptionRequired Message encryption is required or not for all topics in a namespace

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiModifyEncryptionRequiredRequest
*/
func (a *NamespacesApiService) ModifyEncryptionRequired(ctx _context.Context, tenant string, namespace string) ApiModifyEncryptionRequiredRequest {
	return ApiModifyEncryptionRequiredRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) ModifyEncryptionRequiredExecute(r ApiModifyEncryptionRequiredRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.ModifyEncryptionRequired")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/encryptionRequired"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveAutoSubscriptionCreationRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiRemoveAutoSubscriptionCreationRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveAutoSubscriptionCreationExecute(r)
}

/*
RemoveAutoSubscriptionCreation Remove override of broker's allowAutoSubscriptionCreation in a namespace

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiRemoveAutoSubscriptionCreationRequest
*/
func (a *NamespacesApiService) RemoveAutoSubscriptionCreation(ctx _context.Context, tenant string, namespace string) ApiRemoveAutoSubscriptionCreationRequest {
	return ApiRemoveAutoSubscriptionCreationRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) RemoveAutoSubscriptionCreationExecute(r ApiRemoveAutoSubscriptionCreationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.RemoveAutoSubscriptionCreation")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/autoSubscriptionCreation"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveAutoTopicCreationRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiRemoveAutoTopicCreationRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveAutoTopicCreationExecute(r)
}

/*
RemoveAutoTopicCreation Remove override of broker's allowAutoTopicCreation in a namespace

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiRemoveAutoTopicCreationRequest
*/
func (a *NamespacesApiService) RemoveAutoTopicCreation(ctx _context.Context, tenant string, namespace string) ApiRemoveAutoTopicCreationRequest {
	return ApiRemoveAutoTopicCreationRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) RemoveAutoTopicCreationExecute(r ApiRemoveAutoTopicCreationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.RemoveAutoTopicCreation")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/autoTopicCreation"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveInactiveTopicPoliciesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiRemoveInactiveTopicPoliciesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveInactiveTopicPoliciesExecute(r)
}

/*
RemoveInactiveTopicPolicies Remove inactive topic policies from a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiRemoveInactiveTopicPoliciesRequest
*/
func (a *NamespacesApiService) RemoveInactiveTopicPolicies(ctx _context.Context, tenant string, namespace string) ApiRemoveInactiveTopicPoliciesRequest {
	return ApiRemoveInactiveTopicPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) RemoveInactiveTopicPoliciesExecute(r ApiRemoveInactiveTopicPoliciesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.RemoveInactiveTopicPolicies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/inactiveTopicPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveNameSpaceBacklogQuotaRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	backlogQuotaType *string
}

func (r ApiRemoveNameSpaceBacklogQuotaRequest) BacklogQuotaType(backlogQuotaType string) ApiRemoveNameSpaceBacklogQuotaRequest {
	r.backlogQuotaType = &backlogQuotaType
	return r
}

func (r ApiRemoveNameSpaceBacklogQuotaRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveNameSpaceBacklogQuotaExecute(r)
}

/*
RemoveNameSpaceBacklogQuota Remove a backlog quota policy from a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiRemoveNameSpaceBacklogQuotaRequest
*/
func (a *NamespacesApiService) RemoveNameSpaceBacklogQuota(ctx _context.Context, tenant string, namespace string) ApiRemoveNameSpaceBacklogQuotaRequest {
	return ApiRemoveNameSpaceBacklogQuotaRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) RemoveNameSpaceBacklogQuotaExecute(r ApiRemoveNameSpaceBacklogQuotaRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.RemoveNameSpaceBacklogQuota")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/backlogQuota"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.backlogQuotaType != nil {
		localVarQueryParams.Add("backlogQuotaType", parameterToString(*r.backlogQuotaType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveNameSpaceOffloadPoliciesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiRemoveNameSpaceOffloadPoliciesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveNameSpaceOffloadPoliciesExecute(r)
}

/*
RemoveNameSpaceOffloadPolicies  Set offload configuration on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiRemoveNameSpaceOffloadPoliciesRequest
*/
func (a *NamespacesApiService) RemoveNameSpaceOffloadPolicies(ctx _context.Context, tenant string, namespace string) ApiRemoveNameSpaceOffloadPoliciesRequest {
	return ApiRemoveNameSpaceOffloadPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) RemoveNameSpaceOffloadPoliciesExecute(r ApiRemoveNameSpaceOffloadPoliciesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.RemoveNameSpaceOffloadPolicies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/removeOffloadPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveNamespaceAntiAffinityGroupRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiRemoveNamespaceAntiAffinityGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveNamespaceAntiAffinityGroupExecute(r)
}

/*
RemoveNamespaceAntiAffinityGroup Remove anti-affinity group of a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiRemoveNamespaceAntiAffinityGroupRequest
*/
func (a *NamespacesApiService) RemoveNamespaceAntiAffinityGroup(ctx _context.Context, tenant string, namespace string) ApiRemoveNamespaceAntiAffinityGroupRequest {
	return ApiRemoveNamespaceAntiAffinityGroupRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) RemoveNamespaceAntiAffinityGroupExecute(r ApiRemoveNamespaceAntiAffinityGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.RemoveNamespaceAntiAffinityGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/antiAffinity"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveNamespaceMessageTTLRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiRemoveNamespaceMessageTTLRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveNamespaceMessageTTLExecute(r)
}

/*
RemoveNamespaceMessageTTL Set message TTL in seconds for namespace

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiRemoveNamespaceMessageTTLRequest
*/
func (a *NamespacesApiService) RemoveNamespaceMessageTTL(ctx _context.Context, tenant string, namespace string) ApiRemoveNamespaceMessageTTLRequest {
	return ApiRemoveNamespaceMessageTTLRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) RemoveNamespaceMessageTTLExecute(r ApiRemoveNamespaceMessageTTLRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.RemoveNamespaceMessageTTL")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/messageTTL"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRevokePermissionsOnNamespaceRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	role string
}


func (r ApiRevokePermissionsOnNamespaceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RevokePermissionsOnNamespaceExecute(r)
}

/*
RevokePermissionsOnNamespace Revoke all permissions to a role on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param role
 @return ApiRevokePermissionsOnNamespaceRequest
*/
func (a *NamespacesApiService) RevokePermissionsOnNamespace(ctx _context.Context, tenant string, namespace string, role string) ApiRevokePermissionsOnNamespaceRequest {
	return ApiRevokePermissionsOnNamespaceRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		role: role,
	}
}

// Execute executes the request
func (a *NamespacesApiService) RevokePermissionsOnNamespaceExecute(r ApiRevokePermissionsOnNamespaceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.RevokePermissionsOnNamespace")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/permissions/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", _neturl.PathEscape(parameterToString(r.role, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetAutoSubscriptionCreationRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *AutoSubscriptionCreationOverride
}

// Settings for automatic subscription creation
func (r ApiSetAutoSubscriptionCreationRequest) Body(body AutoSubscriptionCreationOverride) ApiSetAutoSubscriptionCreationRequest {
	r.body = &body
	return r
}

func (r ApiSetAutoSubscriptionCreationRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetAutoSubscriptionCreationExecute(r)
}

/*
SetAutoSubscriptionCreation Override broker's allowAutoSubscriptionCreation setting for a namespace

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetAutoSubscriptionCreationRequest
*/
func (a *NamespacesApiService) SetAutoSubscriptionCreation(ctx _context.Context, tenant string, namespace string) ApiSetAutoSubscriptionCreationRequest {
	return ApiSetAutoSubscriptionCreationRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetAutoSubscriptionCreationExecute(r ApiSetAutoSubscriptionCreationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetAutoSubscriptionCreation")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/autoSubscriptionCreation"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetAutoTopicCreationRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *AutoTopicCreationOverride
}

// Settings for automatic topic creation
func (r ApiSetAutoTopicCreationRequest) Body(body AutoTopicCreationOverride) ApiSetAutoTopicCreationRequest {
	r.body = &body
	return r
}

func (r ApiSetAutoTopicCreationRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetAutoTopicCreationExecute(r)
}

/*
SetAutoTopicCreation Override broker's allowAutoTopicCreation setting for a namespace

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetAutoTopicCreationRequest
*/
func (a *NamespacesApiService) SetAutoTopicCreation(ctx _context.Context, tenant string, namespace string) ApiSetAutoTopicCreationRequest {
	return ApiSetAutoTopicCreationRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetAutoTopicCreationExecute(r ApiSetAutoTopicCreationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetAutoTopicCreation")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/autoTopicCreation"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetBookieAffinityGroupRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *BookieAffinityGroupData
}

// Bookie affinity group for the specified namespace
func (r ApiSetBookieAffinityGroupRequest) Body(body BookieAffinityGroupData) ApiSetBookieAffinityGroupRequest {
	r.body = &body
	return r
}

func (r ApiSetBookieAffinityGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetBookieAffinityGroupExecute(r)
}

/*
SetBookieAffinityGroup Set the bookie-affinity-group to namespace-persistent policy.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetBookieAffinityGroupRequest
*/
func (a *NamespacesApiService) SetBookieAffinityGroup(ctx _context.Context, tenant string, namespace string) ApiSetBookieAffinityGroupRequest {
	return ApiSetBookieAffinityGroupRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetBookieAffinityGroupExecute(r ApiSetBookieAffinityGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetBookieAffinityGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/persistence/bookieAffinity"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetIsAllowAutoUpdateSchemaRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *bool
}

// Flag of whether to allow auto update schema
func (r ApiSetIsAllowAutoUpdateSchemaRequest) Body(body bool) ApiSetIsAllowAutoUpdateSchemaRequest {
	r.body = &body
	return r
}

func (r ApiSetIsAllowAutoUpdateSchemaRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetIsAllowAutoUpdateSchemaExecute(r)
}

/*
SetIsAllowAutoUpdateSchema Update flag of whether allow auto update schema

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetIsAllowAutoUpdateSchemaRequest
*/
func (a *NamespacesApiService) SetIsAllowAutoUpdateSchema(ctx _context.Context, tenant string, namespace string) ApiSetIsAllowAutoUpdateSchemaRequest {
	return ApiSetIsAllowAutoUpdateSchemaRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetIsAllowAutoUpdateSchemaExecute(r ApiSetIsAllowAutoUpdateSchemaRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetIsAllowAutoUpdateSchema")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/isAllowAutoUpdateSchema"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetMaxConsumersPerTopicRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *int32
}

// Number of maximum consumers per topic
func (r ApiSetMaxConsumersPerTopicRequest) Body(body int32) ApiSetMaxConsumersPerTopicRequest {
	r.body = &body
	return r
}

func (r ApiSetMaxConsumersPerTopicRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetMaxConsumersPerTopicExecute(r)
}

/*
SetMaxConsumersPerTopic  Set maxConsumersPerTopic configuration on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetMaxConsumersPerTopicRequest
*/
func (a *NamespacesApiService) SetMaxConsumersPerTopic(ctx _context.Context, tenant string, namespace string) ApiSetMaxConsumersPerTopicRequest {
	return ApiSetMaxConsumersPerTopicRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetMaxConsumersPerTopicExecute(r ApiSetMaxConsumersPerTopicRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetMaxConsumersPerTopic")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/maxConsumersPerTopic"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetMaxProducersPerTopicRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *int32
}

// Number of maximum producers per topic
func (r ApiSetMaxProducersPerTopicRequest) Body(body int32) ApiSetMaxProducersPerTopicRequest {
	r.body = &body
	return r
}

func (r ApiSetMaxProducersPerTopicRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetMaxProducersPerTopicExecute(r)
}

/*
SetMaxProducersPerTopic  Set maxProducersPerTopic configuration on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetMaxProducersPerTopicRequest
*/
func (a *NamespacesApiService) SetMaxProducersPerTopic(ctx _context.Context, tenant string, namespace string) ApiSetMaxProducersPerTopicRequest {
	return ApiSetMaxProducersPerTopicRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetMaxProducersPerTopicExecute(r ApiSetMaxProducersPerTopicRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetMaxProducersPerTopic")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/maxProducersPerTopic"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetMaxUnackedMessagesPerConsumerRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *int32
}

// Number of maximum unacked messages per consumer
func (r ApiSetMaxUnackedMessagesPerConsumerRequest) Body(body int32) ApiSetMaxUnackedMessagesPerConsumerRequest {
	r.body = &body
	return r
}

func (r ApiSetMaxUnackedMessagesPerConsumerRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetMaxUnackedMessagesPerConsumerExecute(r)
}

/*
SetMaxUnackedMessagesPerConsumer  Set maxConsumersPerTopic configuration on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetMaxUnackedMessagesPerConsumerRequest
*/
func (a *NamespacesApiService) SetMaxUnackedMessagesPerConsumer(ctx _context.Context, tenant string, namespace string) ApiSetMaxUnackedMessagesPerConsumerRequest {
	return ApiSetMaxUnackedMessagesPerConsumerRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetMaxUnackedMessagesPerConsumerExecute(r ApiSetMaxUnackedMessagesPerConsumerRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetMaxUnackedMessagesPerConsumer")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/maxUnackedMessagesPerConsumer"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetMaxUnackedMessagesPerSubscriptionRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *int32
}

// Number of maximum unacked messages per subscription
func (r ApiSetMaxUnackedMessagesPerSubscriptionRequest) Body(body int32) ApiSetMaxUnackedMessagesPerSubscriptionRequest {
	r.body = &body
	return r
}

func (r ApiSetMaxUnackedMessagesPerSubscriptionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetMaxUnackedMessagesPerSubscriptionExecute(r)
}

/*
SetMaxUnackedMessagesPerSubscription  Set maxUnackedMessagesPerSubscription configuration on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetMaxUnackedMessagesPerSubscriptionRequest
*/
func (a *NamespacesApiService) SetMaxUnackedMessagesPerSubscription(ctx _context.Context, tenant string, namespace string) ApiSetMaxUnackedMessagesPerSubscriptionRequest {
	return ApiSetMaxUnackedMessagesPerSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetMaxUnackedMessagesPerSubscriptionExecute(r ApiSetMaxUnackedMessagesPerSubscriptionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetMaxUnackedMessagesPerSubscription")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/maxUnackedMessagesPerSubscription"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetNameSpaceBacklogQuotaRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	backlogQuotaType *string
	body *BacklogQuota
}

func (r ApiSetNameSpaceBacklogQuotaRequest) BacklogQuotaType(backlogQuotaType string) ApiSetNameSpaceBacklogQuotaRequest {
	r.backlogQuotaType = &backlogQuotaType
	return r
}
// Backlog quota for all topics of the specified namespace
func (r ApiSetNameSpaceBacklogQuotaRequest) Body(body BacklogQuota) ApiSetNameSpaceBacklogQuotaRequest {
	r.body = &body
	return r
}

func (r ApiSetNameSpaceBacklogQuotaRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetNameSpaceBacklogQuotaExecute(r)
}

/*
SetNameSpaceBacklogQuota  Set a backlog quota for all the topics on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetNameSpaceBacklogQuotaRequest
*/
func (a *NamespacesApiService) SetNameSpaceBacklogQuota(ctx _context.Context, tenant string, namespace string) ApiSetNameSpaceBacklogQuotaRequest {
	return ApiSetNameSpaceBacklogQuotaRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetNameSpaceBacklogQuotaExecute(r ApiSetNameSpaceBacklogQuotaRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetNameSpaceBacklogQuota")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/backlogQuota"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.backlogQuotaType != nil {
		localVarQueryParams.Add("backlogQuotaType", parameterToString(*r.backlogQuotaType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetNameSpaceCompactionThresholdRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *int64
}

// Maximum number of uncompacted bytes in a topic of the specified namespace
func (r ApiSetNameSpaceCompactionThresholdRequest) Body(body int64) ApiSetNameSpaceCompactionThresholdRequest {
	r.body = &body
	return r
}

func (r ApiSetNameSpaceCompactionThresholdRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetNameSpaceCompactionThresholdExecute(r)
}

/*
SetNameSpaceCompactionThreshold Set maximum number of uncompacted bytes in a topic before compaction is triggered.

The backlog size is compared to the threshold periodically. A threshold of 0 disabled automatic compaction

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetNameSpaceCompactionThresholdRequest
*/
func (a *NamespacesApiService) SetNameSpaceCompactionThreshold(ctx _context.Context, tenant string, namespace string) ApiSetNameSpaceCompactionThresholdRequest {
	return ApiSetNameSpaceCompactionThresholdRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetNameSpaceCompactionThresholdExecute(r ApiSetNameSpaceCompactionThresholdRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetNameSpaceCompactionThreshold")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/compactionThreshold"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetNameSpaceDeduplicationSnapshotIntervalRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *int32
}

// Interval to take deduplication snapshot per topic
func (r ApiSetNameSpaceDeduplicationSnapshotIntervalRequest) Body(body int32) ApiSetNameSpaceDeduplicationSnapshotIntervalRequest {
	r.body = &body
	return r
}

func (r ApiSetNameSpaceDeduplicationSnapshotIntervalRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetNameSpaceDeduplicationSnapshotIntervalExecute(r)
}

/*
SetNameSpaceDeduplicationSnapshotInterval Set deduplicationSnapshotInterval config on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetNameSpaceDeduplicationSnapshotIntervalRequest
*/
func (a *NamespacesApiService) SetNameSpaceDeduplicationSnapshotInterval(ctx _context.Context, tenant string, namespace string) ApiSetNameSpaceDeduplicationSnapshotIntervalRequest {
	return ApiSetNameSpaceDeduplicationSnapshotIntervalRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetNameSpaceDeduplicationSnapshotIntervalExecute(r ApiSetNameSpaceDeduplicationSnapshotIntervalRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetNameSpaceDeduplicationSnapshotInterval")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/deduplicationSnapshotInterval"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetNameSpaceDelayedDeliveryPoliciesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *DelayedDeliveryPolicies
}

// Delayed delivery policies for the specified namespace
func (r ApiSetNameSpaceDelayedDeliveryPoliciesRequest) Body(body DelayedDeliveryPolicies) ApiSetNameSpaceDelayedDeliveryPoliciesRequest {
	r.body = &body
	return r
}

func (r ApiSetNameSpaceDelayedDeliveryPoliciesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetNameSpaceDelayedDeliveryPoliciesExecute(r)
}

/*
SetNameSpaceDelayedDeliveryPolicies Set delayed delivery messages config on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetNameSpaceDelayedDeliveryPoliciesRequest
*/
func (a *NamespacesApiService) SetNameSpaceDelayedDeliveryPolicies(ctx _context.Context, tenant string, namespace string) ApiSetNameSpaceDelayedDeliveryPoliciesRequest {
	return ApiSetNameSpaceDelayedDeliveryPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetNameSpaceDelayedDeliveryPoliciesExecute(r ApiSetNameSpaceDelayedDeliveryPoliciesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetNameSpaceDelayedDeliveryPolicies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/delayedDelivery"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetNameSpaceDispatchRateRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *DispatchRate
}

// Dispatch rate for all topics of the specified namespace
func (r ApiSetNameSpaceDispatchRateRequest) Body(body DispatchRate) ApiSetNameSpaceDispatchRateRequest {
	r.body = &body
	return r
}

func (r ApiSetNameSpaceDispatchRateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetNameSpaceDispatchRateExecute(r)
}

/*
SetNameSpaceDispatchRate Set dispatch-rate throttling for all topics of the namespace

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetNameSpaceDispatchRateRequest
*/
func (a *NamespacesApiService) SetNameSpaceDispatchRate(ctx _context.Context, tenant string, namespace string) ApiSetNameSpaceDispatchRateRequest {
	return ApiSetNameSpaceDispatchRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetNameSpaceDispatchRateExecute(r ApiSetNameSpaceDispatchRateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetNameSpaceDispatchRate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/dispatchRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetNameSpaceInactiveTopicPoliciesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *InactiveTopicPolicies
}

// Inactive topic policies for the specified namespace
func (r ApiSetNameSpaceInactiveTopicPoliciesRequest) Body(body InactiveTopicPolicies) ApiSetNameSpaceInactiveTopicPoliciesRequest {
	r.body = &body
	return r
}

func (r ApiSetNameSpaceInactiveTopicPoliciesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetNameSpaceInactiveTopicPoliciesExecute(r)
}

/*
SetNameSpaceInactiveTopicPolicies Set inactive topic policies config on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetNameSpaceInactiveTopicPoliciesRequest
*/
func (a *NamespacesApiService) SetNameSpaceInactiveTopicPolicies(ctx _context.Context, tenant string, namespace string) ApiSetNameSpaceInactiveTopicPoliciesRequest {
	return ApiSetNameSpaceInactiveTopicPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetNameSpaceInactiveTopicPoliciesExecute(r ApiSetNameSpaceInactiveTopicPoliciesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetNameSpaceInactiveTopicPolicies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/inactiveTopicPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetNameSpaceMaxConsumersPerSubscriptionRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *int32
}

// Number of maximum consumers per subscription
func (r ApiSetNameSpaceMaxConsumersPerSubscriptionRequest) Body(body int32) ApiSetNameSpaceMaxConsumersPerSubscriptionRequest {
	r.body = &body
	return r
}

func (r ApiSetNameSpaceMaxConsumersPerSubscriptionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetNameSpaceMaxConsumersPerSubscriptionExecute(r)
}

/*
SetNameSpaceMaxConsumersPerSubscription  Set maxConsumersPerSubscription configuration on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetNameSpaceMaxConsumersPerSubscriptionRequest
*/
func (a *NamespacesApiService) SetNameSpaceMaxConsumersPerSubscription(ctx _context.Context, tenant string, namespace string) ApiSetNameSpaceMaxConsumersPerSubscriptionRequest {
	return ApiSetNameSpaceMaxConsumersPerSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetNameSpaceMaxConsumersPerSubscriptionExecute(r ApiSetNameSpaceMaxConsumersPerSubscriptionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetNameSpaceMaxConsumersPerSubscription")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/maxConsumersPerSubscription"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetNameSpaceOffloadPoliciesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *OffloadPolicies
}

// Offload policies for the specified namespace
func (r ApiSetNameSpaceOffloadPoliciesRequest) Body(body OffloadPolicies) ApiSetNameSpaceOffloadPoliciesRequest {
	r.body = &body
	return r
}

func (r ApiSetNameSpaceOffloadPoliciesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetNameSpaceOffloadPoliciesExecute(r)
}

/*
SetNameSpaceOffloadPolicies  Set offload configuration on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetNameSpaceOffloadPoliciesRequest
*/
func (a *NamespacesApiService) SetNameSpaceOffloadPolicies(ctx _context.Context, tenant string, namespace string) ApiSetNameSpaceOffloadPoliciesRequest {
	return ApiSetNameSpaceOffloadPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetNameSpaceOffloadPoliciesExecute(r ApiSetNameSpaceOffloadPoliciesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetNameSpaceOffloadPolicies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/offloadPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetNameSpacePersistenceRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *PersistencePolicies
}

// Persistence policies for the specified namespace
func (r ApiSetNameSpacePersistenceRequest) Body(body PersistencePolicies) ApiSetNameSpacePersistenceRequest {
	r.body = &body
	return r
}

func (r ApiSetNameSpacePersistenceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetNameSpacePersistenceExecute(r)
}

/*
SetNameSpacePersistence Set the persistence configuration for all the topics on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetNameSpacePersistenceRequest
*/
func (a *NamespacesApiService) SetNameSpacePersistence(ctx _context.Context, tenant string, namespace string) ApiSetNameSpacePersistenceRequest {
	return ApiSetNameSpacePersistenceRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetNameSpacePersistenceExecute(r ApiSetNameSpacePersistenceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetNameSpacePersistence")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/persistence"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetNameSpaceRetentionRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *RetentionPolicies
}

// Retention policies for the specified namespace
func (r ApiSetNameSpaceRetentionRequest) Body(body RetentionPolicies) ApiSetNameSpaceRetentionRequest {
	r.body = &body
	return r
}

func (r ApiSetNameSpaceRetentionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetNameSpaceRetentionExecute(r)
}

/*
SetNameSpaceRetention  Set retention configuration on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetNameSpaceRetentionRequest
*/
func (a *NamespacesApiService) SetNameSpaceRetention(ctx _context.Context, tenant string, namespace string) ApiSetNameSpaceRetentionRequest {
	return ApiSetNameSpaceRetentionRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetNameSpaceRetentionExecute(r ApiSetNameSpaceRetentionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetNameSpaceRetention")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/retention"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetNameSpaceSubscribeRateRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *SubscribeRate
}

// Subscribe rate for all topics of the specified namespace
func (r ApiSetNameSpaceSubscribeRateRequest) Body(body SubscribeRate) ApiSetNameSpaceSubscribeRateRequest {
	r.body = &body
	return r
}

func (r ApiSetNameSpaceSubscribeRateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetNameSpaceSubscribeRateExecute(r)
}

/*
SetNameSpaceSubscribeRate Set subscribe-rate throttling for all topics of the namespace

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetNameSpaceSubscribeRateRequest
*/
func (a *NamespacesApiService) SetNameSpaceSubscribeRate(ctx _context.Context, tenant string, namespace string) ApiSetNameSpaceSubscribeRateRequest {
	return ApiSetNameSpaceSubscribeRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetNameSpaceSubscribeRateExecute(r ApiSetNameSpaceSubscribeRateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetNameSpaceSubscribeRate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/subscribeRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetNameSpaceSubscriptionDispatchRateRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *DispatchRate
}

// Subscription dispatch rate for all topics of the specified namespace
func (r ApiSetNameSpaceSubscriptionDispatchRateRequest) Body(body DispatchRate) ApiSetNameSpaceSubscriptionDispatchRateRequest {
	r.body = &body
	return r
}

func (r ApiSetNameSpaceSubscriptionDispatchRateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetNameSpaceSubscriptionDispatchRateExecute(r)
}

/*
SetNameSpaceSubscriptionDispatchRate Set Subscription dispatch-rate throttling for all topics of the namespace

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetNameSpaceSubscriptionDispatchRateRequest
*/
func (a *NamespacesApiService) SetNameSpaceSubscriptionDispatchRate(ctx _context.Context, tenant string, namespace string) ApiSetNameSpaceSubscriptionDispatchRateRequest {
	return ApiSetNameSpaceSubscriptionDispatchRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetNameSpaceSubscriptionDispatchRateExecute(r ApiSetNameSpaceSubscriptionDispatchRateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetNameSpaceSubscriptionDispatchRate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/subscriptionDispatchRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetNamespaceAntiAffinityGroupRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *string
}

// Anti-affinity group for the specified namespace
func (r ApiSetNamespaceAntiAffinityGroupRequest) Body(body string) ApiSetNamespaceAntiAffinityGroupRequest {
	r.body = &body
	return r
}

func (r ApiSetNamespaceAntiAffinityGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetNamespaceAntiAffinityGroupExecute(r)
}

/*
SetNamespaceAntiAffinityGroup Set anti-affinity group for a namespace

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetNamespaceAntiAffinityGroupRequest
*/
func (a *NamespacesApiService) SetNamespaceAntiAffinityGroup(ctx _context.Context, tenant string, namespace string) ApiSetNamespaceAntiAffinityGroupRequest {
	return ApiSetNamespaceAntiAffinityGroupRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetNamespaceAntiAffinityGroupExecute(r ApiSetNamespaceAntiAffinityGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetNamespaceAntiAffinityGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/antiAffinity"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetNamespaceMessageTTLRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *int32
}

// TTL in seconds for the specified namespace
func (r ApiSetNamespaceMessageTTLRequest) Body(body int32) ApiSetNamespaceMessageTTLRequest {
	r.body = &body
	return r
}

func (r ApiSetNamespaceMessageTTLRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetNamespaceMessageTTLExecute(r)
}

/*
SetNamespaceMessageTTL Set message TTL in seconds for namespace

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetNamespaceMessageTTLRequest
*/
func (a *NamespacesApiService) SetNamespaceMessageTTL(ctx _context.Context, tenant string, namespace string) ApiSetNamespaceMessageTTLRequest {
	return ApiSetNamespaceMessageTTLRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetNamespaceMessageTTLExecute(r ApiSetNamespaceMessageTTLRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetNamespaceMessageTTL")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/messageTTL"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetNamespaceReplicationClustersRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *[]string
}

// List of replication clusters
func (r ApiSetNamespaceReplicationClustersRequest) Body(body []string) ApiSetNamespaceReplicationClustersRequest {
	r.body = &body
	return r
}

func (r ApiSetNamespaceReplicationClustersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetNamespaceReplicationClustersExecute(r)
}

/*
SetNamespaceReplicationClusters Set the replication clusters for a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetNamespaceReplicationClustersRequest
*/
func (a *NamespacesApiService) SetNamespaceReplicationClusters(ctx _context.Context, tenant string, namespace string) ApiSetNamespaceReplicationClustersRequest {
	return ApiSetNamespaceReplicationClustersRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetNamespaceReplicationClustersExecute(r ApiSetNamespaceReplicationClustersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetNamespaceReplicationClusters")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/replication"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetOffloadDeletionLagRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *int64
}

// New number of milliseconds to wait before deleting a ledger segment which has been offloaded
func (r ApiSetOffloadDeletionLagRequest) Body(body int64) ApiSetOffloadDeletionLagRequest {
	r.body = &body
	return r
}

func (r ApiSetOffloadDeletionLagRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetOffloadDeletionLagExecute(r)
}

/*
SetOffloadDeletionLag Set number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)

A negative value disables the deletion completely.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetOffloadDeletionLagRequest
*/
func (a *NamespacesApiService) SetOffloadDeletionLag(ctx _context.Context, tenant string, namespace string) ApiSetOffloadDeletionLagRequest {
	return ApiSetOffloadDeletionLagRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetOffloadDeletionLagExecute(r ApiSetOffloadDeletionLagRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetOffloadDeletionLag")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/offloadDeletionLagMs"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetOffloadThresholdRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *int64
}

// Maximum number of bytes stored on the pulsar cluster for a topic of the specified namespace
func (r ApiSetOffloadThresholdRequest) Body(body int64) ApiSetOffloadThresholdRequest {
	r.body = &body
	return r
}

func (r ApiSetOffloadThresholdRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetOffloadThresholdExecute(r)
}

/*
SetOffloadThreshold Set maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage

-1 will revert to using the cluster default. A negative value disables automatic offloading. 

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetOffloadThresholdRequest
*/
func (a *NamespacesApiService) SetOffloadThreshold(ctx _context.Context, tenant string, namespace string) ApiSetOffloadThresholdRequest {
	return ApiSetOffloadThresholdRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetOffloadThresholdExecute(r ApiSetOffloadThresholdRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetOffloadThreshold")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/offloadThreshold"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetReplicatorDispatchRateRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *DispatchRate
}

// Replicator dispatch rate for all topics of the specified namespace
func (r ApiSetReplicatorDispatchRateRequest) Body(body DispatchRate) ApiSetReplicatorDispatchRateRequest {
	r.body = &body
	return r
}

func (r ApiSetReplicatorDispatchRateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetReplicatorDispatchRateExecute(r)
}

/*
SetReplicatorDispatchRate Set replicator dispatch-rate throttling for all topics of the namespace

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetReplicatorDispatchRateRequest
*/
func (a *NamespacesApiService) SetReplicatorDispatchRate(ctx _context.Context, tenant string, namespace string) ApiSetReplicatorDispatchRateRequest {
	return ApiSetReplicatorDispatchRateRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetReplicatorDispatchRateExecute(r ApiSetReplicatorDispatchRateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetReplicatorDispatchRate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/replicatorDispatchRate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetSchemaAutoUpdateCompatibilityStrategyRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *string
}

// Strategy used to check the compatibility of new schemas
func (r ApiSetSchemaAutoUpdateCompatibilityStrategyRequest) Body(body string) ApiSetSchemaAutoUpdateCompatibilityStrategyRequest {
	r.body = &body
	return r
}

func (r ApiSetSchemaAutoUpdateCompatibilityStrategyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetSchemaAutoUpdateCompatibilityStrategyExecute(r)
}

/*
SetSchemaAutoUpdateCompatibilityStrategy Update the strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema

The value AutoUpdateDisabled prevents producers from updating the schema.  If set to AutoUpdateDisabled, schemas must be updated through the REST api

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetSchemaAutoUpdateCompatibilityStrategyRequest
*/
func (a *NamespacesApiService) SetSchemaAutoUpdateCompatibilityStrategy(ctx _context.Context, tenant string, namespace string) ApiSetSchemaAutoUpdateCompatibilityStrategyRequest {
	return ApiSetSchemaAutoUpdateCompatibilityStrategyRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetSchemaAutoUpdateCompatibilityStrategyExecute(r ApiSetSchemaAutoUpdateCompatibilityStrategyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetSchemaAutoUpdateCompatibilityStrategy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/schemaAutoUpdateCompatibilityStrategy"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetSchemaCompatibilityStrategyRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *string
}

// Strategy used to check the compatibility of new schema
func (r ApiSetSchemaCompatibilityStrategyRequest) Body(body string) ApiSetSchemaCompatibilityStrategyRequest {
	r.body = &body
	return r
}

func (r ApiSetSchemaCompatibilityStrategyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetSchemaCompatibilityStrategyExecute(r)
}

/*
SetSchemaCompatibilityStrategy Update the strategy used to check the compatibility of new schema

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetSchemaCompatibilityStrategyRequest
*/
func (a *NamespacesApiService) SetSchemaCompatibilityStrategy(ctx _context.Context, tenant string, namespace string) ApiSetSchemaCompatibilityStrategyRequest {
	return ApiSetSchemaCompatibilityStrategyRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetSchemaCompatibilityStrategyExecute(r ApiSetSchemaCompatibilityStrategyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetSchemaCompatibilityStrategy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/schemaCompatibilityStrategy"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetSchemaValidtionEnforcedRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *bool
}

// Flag of whether validation is enforced on the specified namespace
func (r ApiSetSchemaValidtionEnforcedRequest) Body(body bool) ApiSetSchemaValidtionEnforcedRequest {
	r.body = &body
	return r
}

func (r ApiSetSchemaValidtionEnforcedRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetSchemaValidtionEnforcedExecute(r)
}

/*
SetSchemaValidtionEnforced Set schema validation enforced flag on namespace.

If the flag is set to true, when a producer without a schema attempts to produce to a topic with schema in this namespace, the producer will be failed to connect. PLEASE be carefully on using this, since non-java clients don't support schema.if you enable this setting, it will cause non-java clients failed to produce.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetSchemaValidtionEnforcedRequest
*/
func (a *NamespacesApiService) SetSchemaValidtionEnforced(ctx _context.Context, tenant string, namespace string) ApiSetSchemaValidtionEnforcedRequest {
	return ApiSetSchemaValidtionEnforcedRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetSchemaValidtionEnforcedExecute(r ApiSetSchemaValidtionEnforcedRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetSchemaValidtionEnforced")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/schemaValidationEnforced"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetSubscriptionAuthModeRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *string
}

// Subscription auth mode for all topics of the specified namespace
func (r ApiSetSubscriptionAuthModeRequest) Body(body string) ApiSetSubscriptionAuthModeRequest {
	r.body = &body
	return r
}

func (r ApiSetSubscriptionAuthModeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetSubscriptionAuthModeExecute(r)
}

/*
SetSubscriptionAuthMode  Set a subscription auth mode for all the topics on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetSubscriptionAuthModeRequest
*/
func (a *NamespacesApiService) SetSubscriptionAuthMode(ctx _context.Context, tenant string, namespace string) ApiSetSubscriptionAuthModeRequest {
	return ApiSetSubscriptionAuthModeRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetSubscriptionAuthModeExecute(r ApiSetSubscriptionAuthModeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetSubscriptionAuthMode")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/subscriptionAuthMode"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetSubscriptionExpirationTimeRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	body *int32
}

// Expiration time in minutes for the specified namespace
func (r ApiSetSubscriptionExpirationTimeRequest) Body(body int32) ApiSetSubscriptionExpirationTimeRequest {
	r.body = &body
	return r
}

func (r ApiSetSubscriptionExpirationTimeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetSubscriptionExpirationTimeExecute(r)
}

/*
SetSubscriptionExpirationTime Set subscription expiration time in minutes for namespace

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiSetSubscriptionExpirationTimeRequest
*/
func (a *NamespacesApiService) SetSubscriptionExpirationTime(ctx _context.Context, tenant string, namespace string) ApiSetSubscriptionExpirationTimeRequest {
	return ApiSetSubscriptionExpirationTimeRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SetSubscriptionExpirationTimeExecute(r ApiSetSubscriptionExpirationTimeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SetSubscriptionExpirationTime")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/subscriptionExpirationTime"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSplitNamespaceBundleRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	bundle string
	authoritative *bool
	unload *bool
	splitAlgorithmName *string
}

func (r ApiSplitNamespaceBundleRequest) Authoritative(authoritative bool) ApiSplitNamespaceBundleRequest {
	r.authoritative = &authoritative
	return r
}
func (r ApiSplitNamespaceBundleRequest) Unload(unload bool) ApiSplitNamespaceBundleRequest {
	r.unload = &unload
	return r
}
func (r ApiSplitNamespaceBundleRequest) SplitAlgorithmName(splitAlgorithmName string) ApiSplitNamespaceBundleRequest {
	r.splitAlgorithmName = &splitAlgorithmName
	return r
}

func (r ApiSplitNamespaceBundleRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SplitNamespaceBundleExecute(r)
}

/*
SplitNamespaceBundle Split a namespace bundle

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param bundle
 @return ApiSplitNamespaceBundleRequest
*/
func (a *NamespacesApiService) SplitNamespaceBundle(ctx _context.Context, tenant string, namespace string, bundle string) ApiSplitNamespaceBundleRequest {
	return ApiSplitNamespaceBundleRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		bundle: bundle,
	}
}

// Execute executes the request
func (a *NamespacesApiService) SplitNamespaceBundleExecute(r ApiSplitNamespaceBundleRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.SplitNamespaceBundle")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/{bundle}/split"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bundle"+"}", _neturl.PathEscape(parameterToString(r.bundle, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	if r.unload != nil {
		localVarQueryParams.Add("unload", parameterToString(*r.unload, ""))
	}
	if r.splitAlgorithmName != nil {
		localVarQueryParams.Add("splitAlgorithmName", parameterToString(*r.splitAlgorithmName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnloadNamespaceRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
}


func (r ApiUnloadNamespaceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UnloadNamespaceExecute(r)
}

/*
UnloadNamespace Unload namespace

Unload an active namespace from the current broker serving it. Performing this operation will let the brokerremoves all producers, consumers, and connections using this namespace, and close all topics (includingtheir persistent store). During that operation, the namespace is marked as tentatively unavailable until thebroker completes the unloading action. This operation requires strictly super user privileges, since it wouldresult in non-persistent message loss and unexpected connection closure to the clients.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @return ApiUnloadNamespaceRequest
*/
func (a *NamespacesApiService) UnloadNamespace(ctx _context.Context, tenant string, namespace string) ApiUnloadNamespaceRequest {
	return ApiUnloadNamespaceRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *NamespacesApiService) UnloadNamespaceExecute(r ApiUnloadNamespaceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.UnloadNamespace")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/unload"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnloadNamespaceBundleRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	bundle string
	authoritative *bool
}

func (r ApiUnloadNamespaceBundleRequest) Authoritative(authoritative bool) ApiUnloadNamespaceBundleRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiUnloadNamespaceBundleRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UnloadNamespaceBundleExecute(r)
}

/*
UnloadNamespaceBundle Unload a namespace bundle

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param bundle
 @return ApiUnloadNamespaceBundleRequest
*/
func (a *NamespacesApiService) UnloadNamespaceBundle(ctx _context.Context, tenant string, namespace string, bundle string) ApiUnloadNamespaceBundleRequest {
	return ApiUnloadNamespaceBundleRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		bundle: bundle,
	}
}

// Execute executes the request
func (a *NamespacesApiService) UnloadNamespaceBundleExecute(r ApiUnloadNamespaceBundleRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.UnloadNamespaceBundle")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/{bundle}/unload"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bundle"+"}", _neturl.PathEscape(parameterToString(r.bundle, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnsubscribeNamespaceRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	subscription string
	authoritative *bool
}

func (r ApiUnsubscribeNamespaceRequest) Authoritative(authoritative bool) ApiUnsubscribeNamespaceRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiUnsubscribeNamespaceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UnsubscribeNamespaceExecute(r)
}

/*
UnsubscribeNamespace Unsubscribes the given subscription on all topics on a namespace.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param subscription
 @return ApiUnsubscribeNamespaceRequest
*/
func (a *NamespacesApiService) UnsubscribeNamespace(ctx _context.Context, tenant string, namespace string, subscription string) ApiUnsubscribeNamespaceRequest {
	return ApiUnsubscribeNamespaceRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		subscription: subscription,
	}
}

// Execute executes the request
func (a *NamespacesApiService) UnsubscribeNamespaceExecute(r ApiUnsubscribeNamespaceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.UnsubscribeNamespace")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/unsubscribe/{subscription}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscription"+"}", _neturl.PathEscape(parameterToString(r.subscription, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnsubscribeNamespaceBundleRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	tenant string
	namespace string
	subscription string
	bundle string
	authoritative *bool
}

func (r ApiUnsubscribeNamespaceBundleRequest) Authoritative(authoritative bool) ApiUnsubscribeNamespaceBundleRequest {
	r.authoritative = &authoritative
	return r
}

func (r ApiUnsubscribeNamespaceBundleRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UnsubscribeNamespaceBundleExecute(r)
}

/*
UnsubscribeNamespaceBundle Unsubscribes the given subscription on all topics on a namespace bundle.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenant
 @param namespace
 @param subscription
 @param bundle
 @return ApiUnsubscribeNamespaceBundleRequest
*/
func (a *NamespacesApiService) UnsubscribeNamespaceBundle(ctx _context.Context, tenant string, namespace string, subscription string, bundle string) ApiUnsubscribeNamespaceBundleRequest {
	return ApiUnsubscribeNamespaceBundleRequest{
		ApiService: a,
		ctx: ctx,
		tenant: tenant,
		namespace: namespace,
		subscription: subscription,
		bundle: bundle,
	}
}

// Execute executes the request
func (a *NamespacesApiService) UnsubscribeNamespaceBundleExecute(r ApiUnsubscribeNamespaceBundleRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.UnsubscribeNamespaceBundle")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/namespaces/{tenant}/{namespace}/{bundle}/unsubscribe/{subscription}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.PathEscape(parameterToString(r.tenant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscription"+"}", _neturl.PathEscape(parameterToString(r.subscription, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bundle"+"}", _neturl.PathEscape(parameterToString(r.bundle, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.authoritative != nil {
		localVarQueryParams.Add("authoritative", parameterToString(*r.authoritative, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
